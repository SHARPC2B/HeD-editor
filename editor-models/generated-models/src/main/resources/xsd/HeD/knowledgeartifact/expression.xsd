<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="urn:hl7-org:knowledgeartifact:r1" xmlns:dt="urn:hl7-org:cdsdt:r2" xmlns:sch="http://purl.oclc.org/dsdl/schematron" targetNamespace="urn:hl7-org:knowledgeartifact:r1" elementFormDefault="qualified">
	<xs:annotation>
		<xs:documentation>
			This file defines the core expression components used throughout knowledge artifacts. The core expression components defined here are intended to be general purpose, and beyond the datatypes in the cdsdt namespace, do not reference anything specific to the clinical decision support domain. This layering is intended to isolate the syntactic elements of a general purpose expression language from the more frequently varying elements of clinical decision support.
		</xs:documentation>
	</xs:annotation>
	<xs:complexType name="Expression" abstract="true">
		<xs:annotation>
			<xs:documentation>
				The Expression type defines the abstract base type for all expressions used in the
				HeDS expression language.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="description" type="xs:string" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UnaryExpression" abstract="true">
		<xs:annotation>
			<xs:documentation>
				The UnaryExpression type defines the abstract base type for all expressions
				that take a single argument.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BinaryExpression">
		<xs:annotation>
			<xs:documentation>
				The BinaryExpression type defines the abstract base type for all expressions 
				that take two arguments.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="2" maxOccurs="2"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TernaryExpression">
		<xs:annotation>
			<xs:documentation>
				The TernaryExpression type defines the abstract base type for all expressions 
				that take three arguments.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="3" maxOccurs="3"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NaryExpression" abstract="true">
		<xs:annotation>
			<xs:documentation>
				The Expression type defines an abstract base class for an expression
				that takes any number of arguments, including zero.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ExpressionDef">
		<xs:annotation>
			<xs:documentation>
				The ExpressionDef type defines an expression and an associated
				name that can be referenced by any expression in the artifact.
				The name must be unique within the artifact.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expression" type="Expression"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="ExpressionRef">
		<xs:annotation>
			<xs:documentation>
				The ExpressionRef type defines an expression that references a 
				previously defined NamedExpression. The result of evaluating an 
				ExpressionReference is the result of evaluating the referenced
				NamedExpression.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="name" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ParameterDef">
		<xs:annotation>
			<xs:documentation>
				ParameterDef defines a parameter that can be referenced by name
				anywhere within an expression. Parameters are defined at the artifact
				level, and may be provided as part of the payload for an evaluation
				request. If no parameter value is provided, the default element is
				used to provide the value for the parameter. If no parameter or
				default is provided, the parameter is defined to be null.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="default" type="Expression" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="parameterType" type="xs:QName"/>
	</xs:complexType>
	<xs:complexType name="ParameterRef">
		<xs:annotation>
			<xs:documentation>
				The ParameterRef expression allows the value of a parameter to be referenced
				as part of an expression.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="name" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Literals -->
	<xs:complexType name="Literal">
		<xs:annotation>
			<xs:documentation>
				The Literal type defines a single scalar value. For example, the literal 5,
				the boolean value true or the string "Code".
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="valueType" type="xs:QName" use="required"/>
				<xs:attribute name="value" type="xs:anySimpleType" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Complex literal is not included, the decision was made that this would introduce
	multiple different ways of accomplishing the same thing (namely with a ComplexLiteral, and with
	an ObjectExpression. Given that ObjectExpression is more powerful, it was selected as the preferred
	approach. Note that specific literals are included for the ISO data types. 

	UPDATE: Based on specific feedback from Zynx and others, it is proposed that the ComplexLiteral
	expression be reintroduced to allow static orderable content to be expressed without the need to
	build it up with an expression.
	-->
	<xs:complexType name="ComplexLiteral">
		<xs:annotation>
			<xs:documentation>
				The ComplexLiteral expression allows an xml literal of any type to be
				included in an expression.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="value" type="xs:anyType" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PropertyExpression">
		<xs:annotation>
			<xs:documentation>
				The PropertyExpression type is used within the ObjectLiteral type to 
				provide the value of a specific property within an object literal
				expression.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="value" type="Expression" minOccurs="1" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="ObjectExpression">
		<xs:annotation>
			<xs:documentation>
				The ObjectExpression type allows objects of any type to be built
				up as an expression. The objectType attribute specifies the type of 
				the object being built, and the list of property elements specify
				the values for the properties of the object. Note that the value
				of a property may be any expression, including another ObjectLiteral.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="property" type="PropertyExpression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="objectType" type="xs:QName"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectDescriptor">
		<xs:annotation>
			<xs:documentation>
				The ObjectDescriptor type allows arbitrary object descriptors to be built,
				allowing for the creation of an value that has enough information to uniquely
				identify an object, but is not the object itself. Object descriptors are used as
				part of the update and remove action sentences to allow the object to be
				updated to be described without creating the object itself.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="property" type="PropertyExpression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="objectType" type="xs:QName"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectRedefine">
		<xs:annotation>
			<xs:documentation>
				The ObjectRedefine expression returns an object of the same type as the
				source argument, with the same values for each property, except the values
				of the properties listed in the property elements. For those properties,
				the values will be set based on the expressions in those elements. This
				operator allows an object to be "copied" with new values specified only
				for a given list of properties.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="property" type="PropertyExpression" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Interval selector -->
	<xs:complexType name="Interval">
		<xs:annotation>
			<xs:documentation>
				The Interval selector defines an interval value. An interval must be defined
				on values that support comparison, as well as successor and predecessor values.
				The beginning and ending of the interval may each be defined as open or closed.
				The default is closed, indicating an inclusive interval.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="begin" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="end" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="beginOpen" type="xs:boolean" use="optional" default="false"/>
				<xs:attribute name="endOpen" type="xs:boolean" use="optional" default="false"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Examples 

	<operand xsi:Type="Interval">
		<begin xsi:Type="Literal" valueType="xs:Date" value="2010-10-10"/>
		<end xsi:Type="Literal" valueType="xs:Date" value="2010-10-11"/>
	</operand>

	-->
	<xs:complexType name="List">
		<xs:annotation>
			<xs:documentation>
				The List selector returns a value of type List, whose elements are the result
				of evaluating the arguments to the List selector, in order.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="element" type="Expression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="key" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Logical Operators -->
	<xs:complexType name="And">
		<xs:annotation>
			<xs:documentation>
				The And operator returns the logical conjunction of its arguments. Note that this
				operator is defined as n-ary, allowing any number of arguments. The result
				of And with no arguments is defined to be false. The result of an And with
				a single argument is defined to be the result of the argument. The result of
				and with two arguments is defined using 3-valued logic semantics. This means
				that if either argument is false, the result is false; if both arguments
				are true, the result is true; otherwise, the result is null. The result
				of more than two arguments is defined as successive invocations of And.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Or">
		<xs:annotation>
			<xs:documentation>
				The Or operator returns the logical disjunction of its arguments. Note that
				this operator is defined as n-ary, allowing any number of arguments. The result
				of Or with no arguments is defined to be true. The result of Or with a single
				argument is defined to be the result of the argument. The result of Or with two
				arguments is defined using 3-valued logic semantics. This means that if either
				argument is true, the result is true; if both arguments are false, the result 
				is false; otherwise, the result is null. The result of more than two arguments
				is defined as successive invocations of Or.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Not">
		<xs:annotation>
			<xs:documentation>
				The Not operator returns the logical negation of its argument. If the argument
				is true, the result is false; if the argument is false, the result is true; 
				otherwise, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Conditional">
		<xs:annotation>
			<xs:documentation>
				The Conditional operator evaluates a condition, and returns the then
				argument if condition evaluates to true; otherwise the result
				of the else argument is returned.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="condition" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="then" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="else" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Examples
	<condition xsi:Type="Conditional">
		<condition xsi:type="Equal">
			<operand xsi:type="Property" Path="Name"/>
			<operand xsi:type="Literal" valueType="xs:string" value="Test"/>
		</condition>
		<then xsi:type="Literal" valueType="xs:string" value="Name was Test"/>
		<else xsi:type="Literal" valueType="xs:string" value="Name was not Test"/>
	</condition>
	-->
	<xs:complexType name="CaseItem">
		<xs:sequence>
			<xs:element name="when" type="Expression" minOccurs="1" maxOccurs="1"/>
			<xs:element name="then" type="Expression" minOccurs="1" maxOccurs="1"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Case">
		<xs:annotation>
			<xs:documentation>
				The case operator allows for multiple conditional expressions to
				be chained together in a single expression, rather than having to
				nest multiple Conditional operators.

				In addition, the comparand operand provides a variant on the case that
				allows a single value to be compared in each conditional.

				If a comparand is not provided, the type of each when element of the
				caseItems within the Case is expected to be boolean.

				If a comparand is provided, the type of each when element of the
				caseItems within the Case is expected to be of the same type as the comparand.

				An else element must always be provided.

				The type of all then elements, and the else element, must be the same is,
				and is the resulting type of the Case operator.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="comparand" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="caseItem" type="CaseItem" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element name="else" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Nullological Operators -->
	<!-- NOTE: Maybe may be implemented as a null-test on a boolean-valued expression. I am reluctant to introduce an actual Maybe operator
	because SQL doesn't have a MAYBE operator. (At least, most dialects don't). In fact, even the long-hand described previously (null-test
	on a boolean-valued expression) cannot be translated into SQL.
	-->
	<xs:complexType name="Null">
		<xs:annotation>
			<xs:documentation>
				Returns a typed null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="valueType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IsNull">
		<xs:annotation>
			<xs:documentation>
				Returns true if the argument evaluates to null, false otherwise.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IfNull">
		<xs:annotation>
			<xs:documentation>
				If the first argument evaluates to null, returns the result of the 
				second argument. Otherwise, returns the result of the first argument.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Coalesce">
		<xs:annotation>
			<xs:documentation>
				Returns the result of the first argument that evaluates is not null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Type Operators -->
	<xs:complexType name="Is">
		<xs:annotation>
			<xs:documentation>
				Returns true if the argument is of the specified type.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression">
				<xs:attribute name="isType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="As">
		<xs:annotation>
			<xs:documentation>
				Casts the argument as the specified type. If the argument is not of the specified type, strict determines whether the result is null (the default), or an exception is thrown.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression">
				<xs:attribute name="asType" type="xs:QName" use="required"/>
				<xs:attribute name="strict" type="xs:boolean" use="optional" default="false"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Convert">
		<xs:annotation>
			<xs:documentation>
				Converts a value to a specific type.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression">
				<xs:attribute name="toType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Comparison Operators -->
	<xs:complexType name="Equal">
		<xs:annotation>
			<xs:documentation>
				The Equal operator returns true if the arguments are equal; and false 
				otherwise. Equality semantics are defined to be value-based. This means
				for scalars that equality returns true if and only if the result of
				each argument evaluates to the same value. For object types, this means
				that equality returns true if and only if the objects are of the same
				type, and the values for all properties are the same. For list types,
				this means that equality returns true if and only if the lists contain
				elements of the same type, have the same number of elements, and for
				each element in the lists, the elements are equal using the same semantics.
				For interval types, equality returns true if and only if the intervals
				are over the same point type, and they have the same value for the
				beginning and ending points of the interval. If either argument
				is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NotEqual">
		<xs:annotation>
			<xs:documentation>
				The NotEqual operator returns true if its argument are not the
				same value.

				The NotEqual operator is a shorthand for invocation of logical 
				negation of the Equal operator.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Less">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first argument is less than the second argument.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Greater">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first argument is greater than the second argument.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LessOrEqual">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first argument is less than or equal to the second argument.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GreaterOrEqual">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first argument is greater than or equal to the second argument.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Arithmetic Operators -->
	<xs:complexType name="Add">
		<xs:annotation>
			<xs:documentation>
				The Add operator performs numeric addition of its arguments.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Subtract">
		<xs:annotation>
			<xs:documentation>
				The Subtract operator performs numeric subtraction of its arguments.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Multiply">
		<xs:annotation>
			<xs:documentation>
				The Multiply operator performs numeric multiplication of its arguments.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Divide">
		<xs:annotation>
			<xs:documentation>
				The Divide operator performs numeric division of its arguments.
				Note that the result of Divide is a decimal, even if its arguments
				are integers.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TruncatedDivide">
		<xs:annotation>
			<xs:documentation>
				The TruncatedDivide operator performs integer division of its arguments.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Modulo">
		<xs:annotation>
			<xs:documentation>
				The Modulo operator computes the remainder of the division of its
				arguments. If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Ceiling">
		<xs:annotation>
			<xs:documentation>
				The Ceiling operator returns the first integer greater than or
				equal to the argument. If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Floor">
		<xs:annotation>
			<xs:documentation>
				The Floor operator returns the first integer less than or
				equal to the argument. If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Abs">
		<xs:annotation>
			<xs:documentation>
				The Abs operator returns the absolute value of its argument.
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Negate">
		<xs:annotation>
			<xs:documentation>
				The Negate operator returns the negative of its argument.
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Round">
		<xs:annotation>
			<xs:documentation>
				The Round operator returns the nearest integer to its
				argument. The semantics of round are defined as a traditional
				round, meaning that a decimal value of 0.5 or higher will round
				to 1. If the argument is null, the result is null.
				If specified, precision determines the decimal place at which
				the rounding will occur. If precision is not specified or null, 0 is assumed.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="precision" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Ln">
		<xs:annotation>
			<xs:documentation>
				The Ln operator computes the natural logarithm of its argument.
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Log">
		<xs:annotation>
			<xs:documentation>
				The Log operator computes the logarithm of its first argument,
				using the second argument as the base.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Power">
		<xs:annotation>
			<xs:documentation>
				The Power operator raises the first argument to the power
				given by the second argument.
				If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Succ">
		<xs:annotation>
			<xs:documentation>
				The Succ operator returns the successor of the argument.
				For example, the successor of 1 is 2.
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Pred">
		<xs:annotation>
			<xs:documentation>
				The Pred operator returns the predecessor of the argument.
				For example, the predecessor of 2 is 1.
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- String Operators -->
	<xs:complexType name="Concat">
		<xs:annotation>
			<xs:documentation>
				The Concat operator performs string concatenation
				of its arguments.
				If any argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Combine">
		<xs:annotation>
			<xs:documentation>
				The Combine operator combines a list of strings,
				optionally separating each string with the given
				separator.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="separator" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Split">
		<xs:annotation>
			<xs:documentation>
				The Split operator splits a string into a list of strings using a
				separator. If the stringToSplit argument is null, the result is null.
				If the stringToSplit argument does not contain any appearances of the
				separator, the result is a list of strings containing one element that
				is value of the stringToSplit argument.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="stringToSplit" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="separator" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Length">
		<xs:annotation>
			<xs:documentation>
				Returns the length of its argument. For strings, the length is the number of
				characters in the string. For intervals, the length is defined as the ending
				point minus the beginning point. 
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Upper">
		<xs:annotation>
			<xs:documentation>
				Returns the upper case of its argument.
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Lower">
		<xs:annotation>
			<xs:documentation>
				Returns the lower case of its argument.
				If the argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="First">
		<xs:annotation>
			<xs:documentation>
				Returns the first element in a list. If the order
				by attribute is specified, the list is sorted by that
				ordering prior to returning the first element.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
				<xs:attribute name="orderBy" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Last">
		<xs:annotation>
			<xs:documentation>
				Returns the last element in a list. If the order by
				attribute is specified, the list is sorted by that
				ordering prior to returning the last element.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
				<xs:attribute name="orderBy" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Indexer">
		<xs:annotation>
			<xs:documentation>
				Returns the indexth element in a string or list.
				Indexes in strings and lists are defined to be one-based.
				If either argument is null,	the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="index" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Pos">
		<xs:annotation>
			<xs:documentation>
				Pos returns the 1-based index of the given pattern in the given string.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="pattern" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="string" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Substring">
		<xs:annotation>
			<xs:documentation>
				Substring returns the string within stringToSub, beginning at the 1-based index
				startIndex, and consisting of length characters. If length is ommitted, the
				substring returned starts at startIndex and continues to the end of stringToSub.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="stringToSub" minOccurs="1" maxOccurs="1"/>
					<xs:element name="startIndex" minOccurs="1" maxOccurs="1"/>
					<xs:element name="length" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- TODO: Trimming, Padding, Replicating, Insert, Upper, Lower, IsDigit, IsLetter, IsWhitespace? 
	These operators are not primitive, but they are very useful shorthands. Do we want to leave them out for now? (CREF doesn't actually have any of these, and hasn't needed them so far...)
	-->
	<!-- Temporal Operators -->
	<xs:simpleType name="DateGranularity">
		<xs:annotation>
			<xs:documentation>
				DateGranularity specifies the granularities available for temporal operations
				such as DateAdd, DateDiff, and DatePart.
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Year"/>
			<xs:enumeration value="Month"/>
			<xs:enumeration value="Week"/>
			<xs:enumeration value="Day"/>
			<xs:enumeration value="Hour"/>
			<xs:enumeration value="Minute"/>
			<xs:enumeration value="Second"/>
			<xs:enumeration value="Millisecond"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="DateAdd">
		<xs:annotation>
			<xs:documentation>
				DateAdd adds numberOfPeriods date periods of the specified granularity to the
				given date.
				Note that this is different than adding an Interval to a date time, because for
				operations on granularities such as month and year, the interval is not well-defined
				due to varying month and year lengths. As a result, DateAdd is used to provide
				well-defined and consistent semantics for date arithmetic involving months and years.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="date" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="granularity" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="numberOfPeriods" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--Example
	<operand xsi:Type="DateAdd">
		<date xsi:Type="Property" path="BirthDate"/>
		<granularity xsi:Type="Value" valueType="DateGranularity" value="Month"/>
		<numberOfPeriods xsi:Type="Value" valueType="xs:int" value="-6"/>
	</operand>
	-->
	<xs:complexType name="DateDiff">
		<xs:annotation>
			<xs:documentation>
				DateDiff returns the number of granularity boundaries occurring between
				startDate and endDate.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="startDate" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="endDate" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="granularity" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DatePart">
		<xs:annotation>
			<xs:documentation>
				DatePart returns the granularity component of the given date.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="date" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="granularity" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Today">
		<xs:annotation>
			<xs:documentation>
				Returns the date (with no time component) of the start timestamp associated with
				the evaluation request. See the Now operator for more information on the rationale
				for defining the Today operator in this way.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Now">
		<xs:annotation>
			<xs:documentation>
				Returns the date and time of the start timestamp associated with the
				evaluation request. Now is defined in this way for two reasons:
				1) The operation will always return the same value within any given evaluation,
				ensuring that the result of an expression containing Now will always return the
				same result.
				2) The operation will return the timestamp associated with the evaluation 
				request, allowing the evaluation to be performed with the same timezone
				information as the data delivered with the evaluation request.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Date">
		<xs:annotation>
			<xs:documentation>
				Constructs a date/time value from the given components.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="year" type="xs:int" minOccurs="1" maxOccurs="1"/>
					<xs:element name="month" type="xs:int" minOccurs="1" maxOccurs="1"/>
					<xs:element name="day" type="xs:int" minOccurs="1" maxOccurs="1"/>
					<xs:element name="hour" type="xs:int" minOccurs="0" maxOccurs="1"/>
					<xs:element name="minute" type="xs:int" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="xs:int" minOccurs="0" maxOccurs="1"/>
					<xs:element name="millisecond" type="xs:double" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Rendered unnecessary by the Interval selector
	<xs:complexType name="DateRange">
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="expression" type="Expression"
						minOccurs="2" maxOccurs="2" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType-->
	<!-- Rendered unnecessary by the Interval selector and DateAdd operator
	<xs:complexType name="DateRangeWithin">
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="expression" type="Expression"
						minOccurs="0" maxOccurs="2" />
				</xs:sequence>
				<xs:attribute name="granularity" type="DateGranularity" />
				<xs:attribute name="numberOfPeriods" type="xs:int" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType-->
	<!-- Interval Operators -->
	<!-- Equal (already defined) -->
	<!-- NotEqual (already defined) -->
	<xs:complexType name="Contains">
		<xs:annotation>
			<xs:documentation>
				Returns true if the given source contains the given element.
				There are four overloads of this operator:
					List, T : The type of T must be the same as the element type of the list.
					List, List : The element type of both lists must be the same.
					Interval, T : The type of T must be the same as the point type of the interval.
					Interval, Interval : The point type of both intervals must be the same.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="element" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Within">
		<xs:annotation>
			<xs:documentation>
				Returns true if the given element is in the given interval.
				There are two overloads of this operator:
					T, Interval : The type of T must be the same as the point type of the interval.
					Interval, Interval : The point type of both intervals must be the same.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="element" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="interval" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ProperContains">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first operand contains the second, and is strictly larger.
				There are two overloads of this operator:
					List, List : The element type of both lists must be the same.
					Interval, Interval : The point type of both intervals must be the same.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ProperIn">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first operand is in the second, and is strictly smaller.
				There are two overloads of this operator:
					List, List : The element type of both lists must be the same.
					Interval, Interval : The point type of both intervals must be the same.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Before">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first interval ends before the second one starts.
				In other words, if the ending point of the first interval is less than
				the starting point of the second interval.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="After">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first interval starts after the second one ends.
				In other words, if the starting point of the first interval is greater
				than the ending point of the second interval.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Meets">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first interval ends on the starting point of the second,
				or if the first interval starts on the ending point of the second. In other
				words, if the ending point of the first interval is equal to the starting
				point of the second, or if the starting point of the first interval is
				equal to the ending point of the second.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Overlaps">
		<xs:annotation>
			<xs:documentation>
				Returns true if the first interval overlaps the second. In other
				words, if the ending point of the first interval is greater than
				or equal to the starting point of the second interval, or if the
				starting point of the first interval is less than or equal to
				the ending point of the second interval.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Union">
		<xs:annotation>
			<xs:documentation>
				Returns the union of the operands.
				This operator has two overloads:
					List
					Interval

				For the list overload, this operator returns a list with all
				elements from all operands.

				For the interval overload, this operator returns the interval
				that starts at the earliest starting point in the operands, and
				ends at the latest starting point in the operands. Note that if
				the operands do not overlap, this operator returns null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Intersect">
		<xs:annotation>
			<xs:documentation>
				Returns the intersection of the operands.
				This operator has two overloads:
					List
					Interval

				For the list overload, this operator returns a list with
				the elements that appear in the lists.

				For the interval overload, this operator returns the interval
				that defines the overlapping portion of the operands. Note that
				if the operands do not overlap, this operator returns null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Difference">
		<xs:annotation>
			<xs:documentation>
				Returns the difference of the two operands.
				This operator has two overloads:
					List, List
					Interval, Interval

				For the list overload, this operator returns a list with
				the elements that appear in the first operand, that do not
				appear in the second operand.

				For the interval overload, this operator returns the portion
				of the first interval that does not overlap with the second.
				Note that if the operands do not overlap, or if the second
				operand is completely contained within the first, this operator
				returns null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Length: Already defined in string operators -->
	<xs:complexType name="Begin">
		<xs:annotation>
			<xs:documentation>
				Returns the starting point of the interval operand.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="End">
		<xs:annotation>
			<xs:documentation>
				Returns the ending point of the interval operand.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- List/Set Operators -->
	<xs:complexType name="IsEmpty">
		<xs:annotation>
			<xs:documentation>
				Returns true if the list contains no elements.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IsNotEmpty">
		<xs:annotation>
			<xs:documentation>
				Returns true if the list contains any elements.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Union (already defined) -->
	<!-- Intersect (already defined) -->
	<!-- Difference (already defined) -->
	<xs:complexType name="Filter">
		<xs:annotation>
			<xs:documentation>
				The filter expression returns a list with only those elements
				in the source list for which the condition element evaluates
				to true.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="condition" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Equal (already defined) -->
	<!-- NotEqual (already defined) -->
	<!-- Indexer (already defined) -->
	<xs:complexType name="IndexOf">
		<xs:annotation>
			<xs:documentation>
				IndexOf returns the 1-based index of the given element in the given source list.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="element" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Contains (already defined) -->
	<!-- In -->
	<xs:complexType name="In">
		<xs:annotation>
			<xs:documentation>
				Returns true if the given element is in the source element.
				There are two overloads of this operator:
					T, List : The type of T must be the same as the element type of the list.
					List, List : The element type of both lists must be the same.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="element" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="collection" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ProperContains (already defined) -->
	<!-- ProperIn (already defined) -->
	<xs:complexType name="Sort">
		<xs:annotation>
			<xs:documentation>
				Returns a list with all the elements in source, sorted by the given orderBy.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
				<xs:attribute name="orderBy" type="xs:string" use="required"/>
			</xs:extension>
			<!-- TODO: Model ordering more explicitly? Multi-column sort? Ascending/Descending? -->
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ForEach">
		<xs:annotation>
			<xs:documentation>
				The ForEach expression iterates over the list of elements
				in the source element, and returns a list with the same
				number of elements, where each element in the new list is
				the result of evaluating the element expression for
				each element in the source list.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="element" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Distinct">
		<xs:annotation>
			<xs:documentation>
				The Distinct operator takes a list of elements and returns a list containing
				only the unique elements within the input. For example, given the list of
				integers { 1, 1, 1, 2, 2, 3, 4, 4 }, the result of Distinct would be { 1, 2, 3, 4 }.
				
				The operator uses equality comparison semantics as defined in the Equal
				operator.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Current">
		<xs:annotation>
			<xs:documentation>
				The Current expression returns the value of the object
				currently in scope. For example, within an ForEach
				expression, this returns the current element being
				considered in the iteration.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Aggregate Operators -->
	<!-- TODO: Support grouping? -->
	<xs:complexType name="AggregateExpression" abstract="true">
		<xs:annotation>
			<xs:documentation>
				Aggregate expressions perform operations on lists of data, 
				either directly on a list of scalars, or indirectly on a 
				list of objects, with a reference to a property present 
				on each object in the list.

				Aggregate expressions deal with missing information by 
				excluding missing values from consideration before performing 
				the aggregated operation. For example, in a Sum over Dose, any 
				instance of Medication with no value for Dose would be ignored.

				An aggregate operation performed over an empty list is defined 
				to return null, except as noted in the documentation for each
				operator (Count, AllTrue, and AnyTrue are the exceptions).
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="path" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Count">
		<xs:annotation>
			<xs:documentation>
				Returns the number of non-null elements in the source.

				If a path is specified, the count returns the number of
				elements that have a value for the property specified by the path.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Sum">
		<xs:annotation>
			<xs:documentation>
				Returns the sum of non-null elements in the source.

				If a path is specified, elements with no value for the
				property specified by the path are ignored.

				If source contains no non-null elements, null is returned.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Min">
		<xs:annotation>
			<xs:documentation>
				Returns the minimum element in the source.

				If a path is specified, elements with no value for the
				property specified by the path are ignored.
				
				If source contains no non-null elements, null is returned.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Max">
		<xs:annotation>
			<xs:documentation>
				Returns the maximum element in the source.

				If a path is specified, elements with no value for the
				property specified by the path are ignored.
				
				If source contains no non-null elements, null is returned.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Avg">
		<xs:annotation>
			<xs:documentation>
				Returns the average of the elements in source.

				If a path is specified, elements with no value for the
				property specified by the path are ignored.
				
				If source contains no non-null elements, null is returned.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AllTrue">
		<xs:annotation>
			<xs:documentation>
				Returns true if all the elements in source are true.

				If a path is specified, elements with no value for the
				property specified by the path are ignored.
				
				If source contains no non-null elements, true is returned.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AnyTrue">
		<xs:annotation>
			<xs:documentation>
				Returns true if any element in source is true.

				If a path is specified, elements with no value for the
				property specified by the path are ignored.
				
				If source contains no non-null elements, false is returned.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Data Operators -->
	<xs:complexType name="Property">
		<xs:annotation>
			<xs:documentation>
				Returns the value of the property on source specified by the
				path attribute.

				If the path attribute contains qualifiers, each qualifier is
				traversed to obtain the actual value.

				If a scope is specified, the name is used to resolve the scope
				in which the path will be resolved. Scopes can be named by operators
				such as Filter and ForEach.
				
				Property expressions can also be used to access the individual points
				and open indicators for interval types using the property names begin,
				end, beginOpen, and endOpen.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="path" type="xs:string" use="required"/>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
</xs:schema>
