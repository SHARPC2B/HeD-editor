<?xml version="1.0" encoding="UTF-8"?>

<xsd:schema elementFormDefault="qualified"
targetNamespace="http://www.exampleURI.com/HeD" xmlns="http://www.exampleURI.com/HeD"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://www.ascc.net/xml/schematron">
  <xsd:annotation>
    <xsd:documentation>
Introduction
------------

This XML document was originally developed in the course of development of 
the ISO/HL7 21090 standard (Healthcare Datatypes). This XML document contains 
either a part or all of the Healthcare Datatypes schema implementation for 
Healthcare Datatypes examples conformant to the Healthcare Datatypes schemas.

ISO/HL7 gives users of Healthcare Datatypes free license to this XML document 
or modifications thereof for use in hardware or software products claiming 
conformance to Healthcare Datatypes.

Those intending to use this XML document in hardware or software products are 
advised that its use may infringe existing patents. The original developers 
of this XML document and his/her company, the subsequent editors and their 
companies, and ISO/HL7 have no liability for use of this XML document or 
modifications thereof in an implementation.

Copyright is not released for non Healthcare Datatypes conforming products. 
The organizations who contributed to this XML document retain the full 
right to use the code for their own purpose, assign or donate their 
contribution to a third party and inhibit third parties from using 
their contribution for non Healthcare Datatypes conforming products.

Copyright (c) 2005-2009 ISO/HL7.

This XML document is provided for informative purposes only. If any parts 
of this XML document contradict the normative part of the corresponding 
standard document then the normative part should be used as the definitive 
specification.

This notice must be included in all copies or derivative works.
 
Profiling this schema
---------------------

As described in ISO 21090, conformance profiles are able to 
describe subsets of ISO 21090. If a subset schema is derived
from this schema (by, for instance, deleting types, elements or 
attributes, or by tightening schema or schematron constraints),
this heading documentation (copyright statement, this paragraph,
and the version history) must be reproduced as is, along with a
a section above this one explaining who prepared the revised 
schema, what conformance profile it conforms to, and where the 
conformance profile may be found.

Version History
---------------
Version 0.03 20110113 Technical Correction (Lloyd McKenzie)
  Changes from 0.02:
    Corrected schematron to reflect new names of controlInformationRoot and controlInformationExtension

Version 0.02  20090526 Final Ballot Candidate (Grahame Grieve)
  Changes from 0.01:
    Add documentation for each element
    Remove flavors as schema types
    HXIT: Renamed controlActRoot and controlActExtension to controlInformationRoot and controlInformationExtension
    ANY: made flavorId a set instead of a singleton
    ENXP/ADXP: Introduce XP type and move attributes there
    EN: Reorganise EN.use, ENXP.partType and ENXP.qualifier enumerations
    TEL: add capabilities attribute
    SD.TEXT / SD.TITLE: new types defined
    CD: change codingRationale contents
    II: correct one enumeration value on reliability
    REAL/MO: remove precision attribute
    PQ: remove PQV and redefine PQ and PQR accordingly
    QSC: change code from enumerated attribute to CD
    
Version 0.01  20080317 First Release (Grahame Grieve)

Design Comments
---------------
The class "Factory" at the bottom of the schema is created
as a byproduct of the schema generation process. The class
is left in the schema to assist with testing, and to capture
the schematron constraints for the various datatype flavors defined
in ISO 21090
    </xsd:documentation>
  </xsd:annotation>
  <xsd:simpleType name="NullFlavor">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NI">
        <xsd:annotation>
          <xsd:documentation>No Information : The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="INV">
        <xsd:annotation>
          <xsd:documentation>Invalid : The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variable</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="OTH">
        <xsd:annotation>
          <xsd:documentation>Other : The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="NINF">
        <xsd:annotation>
          <xsd:documentation>Negative Infinity : Negative infinity of numbers</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PINF">
        <xsd:annotation>
          <xsd:documentation>Positive Infinity : Positive infinity of numbers</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="UNC">
        <xsd:annotation>
          <xsd:documentation>Unencoded : No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DER">
        <xsd:annotation>
          <xsd:documentation>Derived : An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="UNK">
        <xsd:annotation>
          <xsd:documentation>Unknown : A proper value is applicable, but not known </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ASKU">
        <xsd:annotation>
          <xsd:documentation>Asked But Unknown : Information was sought but not found (e.g., patient was asked but didn&#39;t know) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="NAV">
        <xsd:annotation>
          <xsd:documentation>Temporarily Unavailable : Information is not available at this time but it is expected that it will be available later </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="NASK">
        <xsd:annotation>
          <xsd:documentation>Not Asked : This information has not been sought (e.g., patient was not asked) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="QS">
        <xsd:annotation>
          <xsd:documentation>Sufficient Quantity : The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.&#39;Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.&#39; The null flavor would be used to express the quantity of water</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="TRC">
        <xsd:annotation>
          <xsd:documentation>Trace : The content is greater than zero, but too small to be quantified</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="MSK">
        <xsd:annotation>
          <xsd:documentation>Masked : There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Warning: Using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detail</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="NA">
        <xsd:annotation>
          <xsd:documentation>Not Applicable : No proper value is applicable in this context (e.g., last menstrual period for a male) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="UpdateMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="A">
        <xsd:annotation>
          <xsd:documentation>Add : The item was (or is to be) added, having not been present immediately before. (If it is already present, this may be treated as an error condition.)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="D">
        <xsd:annotation>
          <xsd:documentation>Remove : The item was (or is to be) removed (sometimes referred to as deleted). If the item is part of a collection, delete any matching items.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="R">
        <xsd:annotation>
          <xsd:documentation>Replace : The item existed previously and has been (or is to be) revised. (If an item does not already exist, this may be treated as an error condition.)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="AR">
        <xsd:annotation>
          <xsd:documentation>Add or Replace  : The item was (or is to be) either added or replaced. No assertion is made as to whether the item previously existed</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="N">
        <xsd:annotation>
          <xsd:documentation>No Change : There was (or is to be) no change to the item. This is primarily used when this element has not changed, but other attributes in the instance have changed.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="U">
        <xsd:annotation>
          <xsd:documentation>Unknown : It is not specified whether or what kind of change has occurred to the item, or whether the item is present as a reference or identifying property.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="K">
        <xsd:annotation>
          <xsd:documentation>Key : This item is part of the identifying information for the object that contains it</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Compression">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="DF">
        <xsd:annotation>
          <xsd:documentation>Deflate : The deflate compressed data format as specified in IETF RFC 1951</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="GZ">
        <xsd:annotation>
          <xsd:documentation>GZIP : A compressed data format that is compatible with the widely used GZIP utility as specified in IETF RFC 1952(uses the deflate algorithm)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ZL">
        <xsd:annotation>
          <xsd:documentation>ZLIB : A compressed data format that also uses the deflate algorithm. Specified as IETF RFC 1950</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="Z">
        <xsd:annotation>
          <xsd:documentation>Compress : Original UNIX compress algorithm and file format using the LZC algorithm (a variant of LZW). Patent encumbered and less efficient than deflate </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="BZ">
        <xsd:annotation>
          <xsd:documentation>BZIP : bzip-2 compression format. See [http://www.bzip.org/] for more information.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="Z7">
        <xsd:annotation>
          <xsd:documentation>Z7 : 7z compression file format. See [http://www.7-zip.org/7z.html] for more information. </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IntegrityCheckAlgorithm">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHA1">
        <xsd:annotation>
          <xsd:documentation>Secure Hash Algorithm - 1 : This algorithm is defined in FIPS PUB 180-1: Secure Hash Standard. As of April 17, 1995 </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SHA256">
        <xsd:annotation>
          <xsd:documentation>Secure Hash Algorithm - 256 : This algorithm is defined in FIPS PUB 180-2: Secure Hash Standard </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TelecommunicationAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H">
        <xsd:annotation>
          <xsd:documentation>Home address : A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="HP">
        <xsd:annotation>
          <xsd:documentation>Primary Home : The primary home, to reach a person after business hours </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="HV">
        <xsd:annotation>
          <xsd:documentation>Vacation Home : A vacation home, to reach a person while on vacation </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="WP">
        <xsd:annotation>
          <xsd:documentation>Work Place : An office address. First choice for business related contacts during business hours </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DIR">
        <xsd:annotation>
          <xsd:documentation>Direct : Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries. For phones, often referred to as a &#39;private line&#39; </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PUB">
        <xsd:annotation>
          <xsd:documentation>Public : Indicates a work place address or telecommunication address that is a &#39;standard&#39; address which may reach a reception service, mail-room, or other intermediary prior to the target entity </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="BAD">
        <xsd:annotation>
          <xsd:documentation>Bad address : A flag indicating that the address is bad, in fact, useless </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="TMP">
        <xsd:annotation>
          <xsd:documentation>Temporary address : A temporary address, may be good for visit or mailing. Note that an address history can provide more detailed information </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="AS">
        <xsd:annotation>
          <xsd:documentation>Answering Service : An automated answering machine used for less urgent cases and if the main purpose of contact is to leave a message or access an automated announcement</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="EC">
        <xsd:annotation>
          <xsd:documentation>Emergency Contact : A contact specifically designated to be used for emergencies. This is the first choice in emergencies, independent of any other use codes </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="MC">
        <xsd:annotation>
          <xsd:documentation>Mobile Contact : A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PG">
        <xsd:annotation>
          <xsd:documentation>Pager: A paging device suitable to solicit a callback or to leave a very short message </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_TelecommunicationAddressUse">
    <xsd:list itemType="TelecommunicationAddressUse" />
  </xsd:simpleType>
  <xsd:simpleType name="TelecommunicationCapability">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="voice">
        <xsd:annotation>
          <xsd:documentation>Voice : This device can receive voice calls (i.e. talking to another person, or a recording device, or a voice activated computer)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="fax">
        <xsd:annotation>
          <xsd:documentation>Fax : This device can receive faxes.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="data">
        <xsd:annotation>
          <xsd:documentation>Data : This device can receive data calls (i.e. modem)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="tty">
        <xsd:annotation>
          <xsd:documentation>Text : This device is a text telephone.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="sms">
        <xsd:annotation>
          <xsd:documentation>SMS : This device can receive SMS messages</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_TelecommunicationCapability">
    <xsd:list itemType="TelecommunicationCapability" />
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BUSN">
        <xsd:annotation>
          <xsd:documentation>Business identifier : An identifier whose scope is defined by business practices associated with the object. In contrast to the other scope identifiers, the scope of the use of the id is not necessarily restricted to a single object, but may be reused for other objects closely associated with the object due to business practice</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="OBJ">
        <xsd:annotation>
          <xsd:documentation>Object identifier : The identifier associated with a particular object. It remains consistent as the object undergoes state transitions</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="VER">
        <xsd:annotation>
          <xsd:documentation>Version Identifier : An identifier that references a particular object as it existed at a given point in time.

The identifier SHALL change with each state transition on the object. I.e. The version identifier of an object prior to a &#39;suspend&#39; state transition is distinct from the identifier of the object after the state transition. Each version identifier can be tied to exactly one ControlAct event which brought that version into being (though the control act may never be instantiated). NOTE: Applications that do not support versioning of objects must ignore and not persist these ids to avoid confusion resulting from leaving the same identifier on an object that undergoes changes</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="VW">
        <xsd:annotation>
          <xsd:documentation>View specific identifier : An identifier for a particular snapshot of a version of the object.

This identifies a view of the business object at a particular point in time, and as such identifies a set of data items that can be digitally signed and/or attested. This is in contrast to the Version Identifier which identifies the object at a specific time, but not the amount of information being asserted about the object. This identifier would be changed when a transformation of the information is performed (eg to add code translations, to provide a simplified textual rendering, or to provide additional information about the object as it existed at the specific point in time) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierReliability">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ISS">
        <xsd:annotation>
          <xsd:documentation>Issued by system : The identifier was issued by the system responsible for constructing the instance</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="VRF" />
      <xsd:enumeration value="UNV">
        <xsd:annotation>
          <xsd:documentation>Unverified by system : The identifier was provided to the system that constructed the instance, but has not been verified. e.g. a Driver&#39;s licence entered manually into a system by a user</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="AddressPartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="AL">
        <xsd:annotation>
          <xsd:documentation>Address Line : An address line is for either an additional locator, a delivery address or a street address. An address generally has only a delivery address line or a street address line, but not both</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ADL">
        <xsd:annotation>
          <xsd:documentation>Additional Locator : This can be a unit designator, such as apartment number, suite number, or floor. There may be several unit designators in an address (e.g., &#34;3rd floor, Appt. 342&#34;). This can also be a designator pointing away from the location, rather than specifying a smaller location within some larger one (e.g., Dutch &#34;t.o.&#34; means &#34;opposite to&#34; for house boats located across the street facing houses)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="UNID">
        <xsd:annotation>
          <xsd:documentation>Unit Identifier : The number or name of a specific unit contained within a building or complex, as assigned by that building or complex</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="UNIT">
        <xsd:annotation>
          <xsd:documentation>Unit Designator : Indicates the type of specific unit contained within a building or complex. E.g. Apartment, Floor </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DAL">
        <xsd:annotation>
          <xsd:documentation>Delivery Address Line : A delivery address line is frequently used instead of breaking out delivery mode, delivery installation, etc. An address generally has only a delivery address line or a street address line, but not both.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DINST">
        <xsd:annotation>
          <xsd:documentation>Delivery Installation Type : Indicates the type of delivery installation (the facility to which the mail will be delivered prior to final shipping via the delivery mode.) Example: post office, letter carrier depot, community mail center, station, etc.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DINSTA">
        <xsd:annotation>
          <xsd:documentation>Delivery Installation Area : The location of the delivery installation, usually a town or city, and is only required if the area is different from the municipality. Area to which mail delivery service is provided from any postal facility or service such as an individual letter carrier, rural route, or postal route</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DINSTQ">
        <xsd:annotation>
          <xsd:documentation>Delivery Installation Qualifier : A number, letter or name identifying a delivery installation. E.g., for Station A, the delivery installation qualifier would be &#39;A&#39;.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DMOD">
        <xsd:annotation>
          <xsd:documentation>Delivery Mode : Indicates the type of service offered, method of delivery. For example: post office box, rural route, general delivery, etc.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DMODID">
        <xsd:annotation>
          <xsd:documentation>Delivery Mode Identifier: Represents the routing information such as a letter carrier route number. It is the identifying number of the designator (the box number or rural route number)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SAL">
        <xsd:annotation>
          <xsd:documentation>Street Address Line : A street address line is frequently used instead of breaking out build number, street name, street type, etc. An address generally has only a delivery address line or a street address line, but not both.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="BNR">
        <xsd:annotation>
          <xsd:documentation>Building Number : The number of a building, house or lot alongside the street. Also known as &#34;primary street number&#34;. This does not number the street but rather the building</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="BNN">
        <xsd:annotation>
          <xsd:documentation>Building Number Numeric : The numeric portion of a building number </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="BNS">
        <xsd:annotation>
          <xsd:documentation>Building Number Suffix : Any alphabetic character, fraction or other text that may appear after the numeric portion of a building number </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="STR">
        <xsd:annotation>
          <xsd:documentation>Street Name : The name of the street, including the type</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="STB">
        <xsd:annotation>
          <xsd:documentation>Street Name Base : The base name of a roadway or artery recognized by a municipality (excluding street type and direction) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="STTYP">
        <xsd:annotation>
          <xsd:documentation>Street Type : The designation given to the street. (e.g. Street, Avenue, Crescent, etc.) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DIR">
        <xsd:annotation>
          <xsd:documentation>Direction : Direction (e.g., N, S, W, E) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="INT">
        <xsd:annotation>
          <xsd:documentation>Intersection : An intersection denotes that the actual address is located at or close to the intersection of two or more streets</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CAR">
        <xsd:annotation>
          <xsd:documentation>Care of : The name of the party who will take receipt at the specified address, and will take on responsibility for ensuring delivery to the target recipient.

Note: This is included only to support the convention of writing c/- address lines. This item is not appropriate for use when information is entrusted to one party on behalf of another in some significant way.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CEN">
        <xsd:annotation>
          <xsd:documentation>Census Tract : A geographic sub-unit delineated for demographic purposes </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CNT">
        <xsd:annotation>
          <xsd:documentation>Country : Country</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CPA">
        <xsd:annotation>
          <xsd:documentation>County or Parish : A sub-unit of a state or province. (49 of the United States of America use the term &#34;county;&#34; Louisiana uses the term &#34;parish&#34;) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CTY">
        <xsd:annotation>
          <xsd:documentation>Municipality : The name of the city, town, village, or other community or delivery center </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DEL">
        <xsd:annotation>
          <xsd:documentation>Delimiter : Delimiters are printed without framing white space. If no value component is provided, the delimiter appears as a line break</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="POB">
        <xsd:annotation>
          <xsd:documentation>Post box : A numbered box located in a post station </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PRE">
        <xsd:annotation>
          <xsd:documentation>Precinct : A subsection of a municipality </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="STA">
        <xsd:annotation>
          <xsd:documentation>State or Province : A sub-unit of a country with limited sovereignty in a federally organized country</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ZIP">
        <xsd:annotation>
          <xsd:documentation>Postal Code : A postal code designating a region defined by the postal service</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DPID">
        <xsd:annotation>
          <xsd:documentation>Delivery Point Identifier : A value that uniquely identifies the postal address</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PostalAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H">
        <xsd:annotation>
          <xsd:documentation>Home address : A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="HP">
        <xsd:annotation>
          <xsd:documentation>Primary home : The primary home, to reach a person after business hours </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="HV">
        <xsd:annotation>
          <xsd:documentation>Vacation home : A vacation home, to reach a person while on vacation </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="WP">
        <xsd:annotation>
          <xsd:documentation>Work place : An office address. First choice for business related contacts during business hours </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DIR">
        <xsd:annotation>
          <xsd:documentation>Direct : Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries. For phones, often referred to as a &#39;private line&#39; </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PUB">
        <xsd:annotation>
          <xsd:documentation>Public : Indicates a work place address or telecommunication address that is a &#39;standard&#39; address which may reach a reception service, mail-room, or other intermediary prior to the target entity </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="BAD">
        <xsd:annotation>
          <xsd:documentation>Bad address : A flag indicating that the address is bad, in fact, useless </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PHYS">
        <xsd:annotation>
          <xsd:documentation>Physical Visit Address : Used primarily to visit an address</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PST">
        <xsd:annotation>
          <xsd:documentation>Postal Address : Used to send mail</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="TMP">
        <xsd:annotation>
          <xsd:documentation>Temporary Address : A temporary address, may be good for visit or mailing. Note that an address history can provide more detailed information.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ABC">
        <xsd:annotation>
          <xsd:documentation>Alphabetic : Alphabetic transcription of name (Japanese: romaji) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="IDE">
        <xsd:annotation>
          <xsd:documentation>Ideographic : Ideographic representation of name (e.g., Japanese kanji, Chinese characters) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SYL">
        <xsd:annotation>
          <xsd:documentation>Syllabic : Syllabic transcription of name (e.g., Japanese kana, Korean hangul) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SRCH">
        <xsd:annotation>
          <xsd:documentation>Search Type Uses : A name intended for use in searching or matching.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SNDX">
        <xsd:annotation>
          <xsd:documentation>Soundex : An address spelled according to the SoundEx algorithm</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PHON">
        <xsd:annotation>
          <xsd:documentation>Phonetic : The address as understood by the data enterer, i.e. a close approximation of a phonetic spelling of the address, not based on a phonetic algorithm</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_PostalAddressUse">
    <xsd:list itemType="PostalAddressUse" />
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="FAM">
        <xsd:annotation>
          <xsd:documentation>Family : Family name, this is the name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="GIV">
        <xsd:annotation>
          <xsd:documentation>Given: Given name.
Note: don&#39;t call it &#34;first name&#34; since this given names do not always come first</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="TITLE">
        <xsd:annotation>
          <xsd:documentation>Title : Part of the name that is acquired as a title due to academic, legal, employment or nobility status etc.
Note: Title name parts include name parts that come after the name such as qualifications</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DEL">
        <xsd:annotation>
          <xsd:documentation>Delimiter : A delimiter has no meaning other than being literally printed in this name representation. A delimiter has no implicit leading and trailing white space</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartQualifier">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LS">
        <xsd:annotation>
          <xsd:documentation>Legal Status : For organizations a suffix indicating the legal status, e.g., &#34;Inc.&#34;, &#34;Co.&#34;, &#34;AG&#34;, &#34;GmbH&#34;, &#34;B.V.&#34; &#34;S.A.&#34;, &#34;Ltd.&#34; Etc.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="AC">
        <xsd:annotation>
          <xsd:documentation>Academic : Indicates that a prefix like &#34;Dr.&#34; or a suffix like &#34;M.D.&#34; or &#34;Ph.D.&#34; is an academic title </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="NB">
        <xsd:annotation>
          <xsd:documentation>Nobility : In Europe and Asia, there are still people with nobility titles (aristocrats). German &#34;von&#34; is generally a nobility title, not a mere voorvoegsel. Others are &#34;Earl of&#34; or &#34;His Majesty King of...&#34; etc. Rarely used nowadays, but some systems do keep track of this </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PR">
        <xsd:annotation>
          <xsd:documentation>Professional : Primarily in the British Imperial culture people tend to have an abbreviation of their professional organization as part of their credential suffices </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="HON">
        <xsd:annotation>
          <xsd:documentation>Honorific : A honorific such as &#34;The Right Honourable&#34; or &#34;Weledelgeleerde Heer&#34;.  </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="BR">
        <xsd:annotation>
          <xsd:documentation>Birth : A name that a person was given at birth or established as a consequence of adoption.  

Note: this is not used for temporary names assigned at birth such as &#34;Baby of Smith&#34; - which is just a name with a use code of &#34;TEMP&#34;.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="AD">
        <xsd:annotation>
          <xsd:documentation>Acquired : A name part a person acquired.  

The name part may be acquired by adoption, or the person may have chosen to use the name part for some other reason.

Note: this differs from an Other/Psuedonym/Alias in that an acquired name part is acquired on a formal basis rather than an informal one (e.g. registered as part of the official name)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SP">
        <xsd:annotation>
          <xsd:documentation>Spouse : The name assumed from the partner in a marital relationship. Usually the spouse&#39;s family name. Note that no inference about gender can be made from the existence of spouse names</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="MID">
        <xsd:annotation>
          <xsd:documentation>Middle Name : Indicates that the name part is a middle name.
Usage Notes:
In general, the english &#39;middle name&#39; concept is all of the given names after the first. This qualifier may be used to explicitly indicate which given names are considered to be middle names. 
The middle name qualifier may also be used with family names. This is a Scandinavian use case, matching the concept of &#34;mellomnavn&#34; / &#34;mellannamn&#34;. Note that there are specific rules that indicate what names may be taken as a mellannamn in different Scandinavian countries</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CL">
        <xsd:annotation>
          <xsd:documentation>Callme : Callme is used to indicate which of the various name parts is used when interacting with the person</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="IN">
        <xsd:annotation>
          <xsd:documentation>Initial : Indicates that a name part is just an initial. Initials do not imply a trailing period since this would not work with non-Latin scripts. Initials may consist of more than one letter, e.g., &#34;Ph.&#34; could stand for &#34;Philippe&#34; or &#34;Th.&#34; for &#34;Thomas&#34;</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PFX">
        <xsd:annotation>
          <xsd:documentation>Prefix : A prefix has a strong association to the immediately following name part. A prefix has no implicit trailing white space (it has implicit leading white space though).</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SFX">
        <xsd:annotation>
          <xsd:documentation>Suffix : A suffix has a strong association to the immediately preceding name part. A suffix has no implicit leading white space (it has implicit trailing white space though).</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNamePartQualifier">
    <xsd:list itemType="EntityNamePartQualifier" />
  </xsd:simpleType>
  <xsd:simpleType name="EntityNameUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ABC">
        <xsd:annotation>
          <xsd:documentation>Alphabetic : Alphabetic transcription of name (Japanese: romaji) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SYL">
        <xsd:annotation>
          <xsd:documentation>Syllabic : Syllabic transcription of name (e.g., Japanese kana, Korean hangul) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="IDE">
        <xsd:annotation>
          <xsd:documentation>Ideographic : Ideographic representation of name (e.g., Japanese kanji, Chinese characters) </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="C">
        <xsd:annotation>
          <xsd:documentation>Customary : Known as/conventional/the one you normally use</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="OR">
        <xsd:annotation>
          <xsd:documentation>Official Registry Name : the formal name as registered in an official (government) registry, but which name might not be commonly used. May correspond to the concept of legal name</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="T">
        <xsd:annotation>
          <xsd:documentation>Temporary : A temporary name.  Note that a name valid time can provide more detailed information.  This may also be used for temporary names assigned at birth or in emergency situations.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="I">
        <xsd:annotation>
          <xsd:documentation>Indigenous/Tribal : e.g. Chief Red Cloud </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="P">
        <xsd:annotation>
          <xsd:documentation>Other/Pseudonym/Alias: A non-official name by which the person is sometimes known.  (This may also be used to record informal names such as a nickname)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ANON">
        <xsd:annotation>
          <xsd:documentation>Anonymous : Anonymous assigned name (used to protect a person&#39;s identity for privacy reasons)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="A">
        <xsd:annotation>
          <xsd:documentation>Business Name : A name used in a Professional or Business context .
  
Examples: Continuing to use a maiden name in a professional context, or using a stage performing name (some of these names are also pseudonyms)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="R">
        <xsd:annotation>
          <xsd:documentation>Religious : A name assumed as part of a religious vocation. e.g. Sister Mary Francis, Brother John </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="OLD">
        <xsd:annotation>
          <xsd:documentation>No Longer in Use : This name is no longer in use (note: Names may also carry valid time ranges .  This code is used to cover the situations where it is known that the name is no longer valid, but no particular time range for its use is known)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="DN">
        <xsd:annotation>
          <xsd:documentation>Do Not Use : This name should no longer be used when interacting with the person (i.e .  in addition to no longer being used, the name should not be even mentioned when interacting with the person)

Note: applications are not required to compare names labeled &#34;Do Not Use&#34; and other names in order to eliminate name parts that are common between the other name and a name labeled &#34;Do Not Use&#34;.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="M">
        <xsd:annotation>
          <xsd:documentation>Maiden Name : A name used prior to marriage.

Note that marriage naming customs vary greatly around the world.  This name use is for use by applications that collect and store &#34;maiden&#34; names.  Though the concept of maiden name is often gender specific, the use of this term is not gender specific.  The use of this term does not imply any particular history for a person&#39;s name, nor should the maiden name be determined algorithmically</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="SRCH">
        <xsd:annotation>
          <xsd:documentation>Search Type Uses: A name intended for use in searching or matching</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PHON">
        <xsd:annotation>
          <xsd:documentation>Phonetic : The name as understood by the data enterer, i.e. a close approximation of a phonetic spelling of the name, not based on a phonetic algorithm.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNameUse">
    <xsd:list itemType="EntityNameUse" />
  </xsd:simpleType>
  <xsd:simpleType name="CalendarCycle">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CY" />
      <xsd:enumeration value="MY" />
      <xsd:enumeration value="CM" />
      <xsd:enumeration value="CW" />
      <xsd:enumeration value="WM" />
      <xsd:enumeration value="WY" />
      <xsd:enumeration value="DM" />
      <xsd:enumeration value="CD" />
      <xsd:enumeration value="DY" />
      <xsd:enumeration value="DW" />
      <xsd:enumeration value="HD" />
      <xsd:enumeration value="CH" />
      <xsd:enumeration value="NH" />
      <xsd:enumeration value="CN" />
      <xsd:enumeration value="SN" />
      <xsd:enumeration value="CS" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TimingEvent">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="HS">
        <xsd:annotation>
          <xsd:documentation>HS : the hour of sleep</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="WAKE">
        <xsd:annotation>
          <xsd:documentation>WAKE : upon waking</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="AC">
        <xsd:annotation>
          <xsd:documentation>AC : before meal (from lat. ante cibus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ACM">
        <xsd:annotation>
          <xsd:documentation>ACM : before breakfast (from lat. ante cibus matutinus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ACD">
        <xsd:annotation>
          <xsd:documentation>ACD : before lunch (from lat. ante cibus diurnus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ACV">
        <xsd:annotation>
          <xsd:documentation>ACV : before dinner (from lat. ante cibus vespertinus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="IC">
        <xsd:annotation>
          <xsd:documentation>IC : between meals (from lat. inter cibus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ICM">
        <xsd:annotation>
          <xsd:documentation>ICM : between breakfast and lunch</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ICD">
        <xsd:annotation>
          <xsd:documentation>ICD : between lunch and dinner</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="ICV">
        <xsd:annotation>
          <xsd:documentation>ICV : between dinner and the hour of sleep</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PC">
        <xsd:annotation>
          <xsd:documentation>PC : after meal (from lat. post cibus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PCM">
        <xsd:annotation>
          <xsd:documentation>PCM : after breakfast (from lat. post cibus matutinus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PCD">
        <xsd:annotation>
          <xsd:documentation>PCD: after lunch (from lat. post cibus diurnus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PCV">
        <xsd:annotation>
          <xsd:documentation>PCV : after dinner (from lat. post cibus vespertinus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="C">
        <xsd:annotation>
          <xsd:documentation>C : meal (from lat. cibus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CM">
        <xsd:annotation>
          <xsd:documentation>CM : breakfast (from lat. cibus matutinus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CD">
        <xsd:annotation>
          <xsd:documentation>CD : lunch (from lat. cibus diurnus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="CV">
        <xsd:annotation>
          <xsd:documentation>CV : dinner (from lat. cibus vespertinus)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CodingRationale">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="O">
        <xsd:annotation>
          <xsd:documentation>Original : Originally produced code </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="P">
        <xsd:annotation>
          <xsd:documentation>Post-coded : post-coded from free text source </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="R">
        <xsd:annotation>
          <xsd:documentation>Required : Required by the specification describing the use of the coded concept.The exact form of the requirement is not specified here; it may be required by the specification directly, or it may arise as an indirect result of other conformance tools. More than one different requirement may exist simultaineously, so more than one code in a CD complex may be required</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="OR">
        <xsd:annotation>
          <xsd:documentation>Original &#38;amp; Required :Originally produced code, required by the specification describing the use of the coded concept.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="PR">
        <xsd:annotation>
          <xsd:documentation>Post-coded &#38;amp; Requierd : post-coded from free text source, required by the specification describing the use of the coded concept</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_CodingRationale">
    <xsd:list itemType="CodingRationale" />
  </xsd:simpleType>
  <xsd:simpleType name="UncertaintyType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="U">
        <xsd:annotation>
          <xsd:documentation>Uniform : The uniform distribution assigns a constant probability over the entire interval of possible outcomes, while all outcomes outside this interval are assumed to have zero probability. The width of this interval is 2 s v3. Thus, the uniform distribution assigns the probability densities f(x) = (2 s v3)-1 to values  - s v3 = x =  + s v3 and f(x) = 0 otherwise</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="N">
        <xsd:annotation>
          <xsd:documentation>Normal (Gaussian) : This is the well-known bell-shaped normal distribution. Because of the central limit theorem, the normal distribution is the distribution of choice for an unbounded random variable that is an outcome of a combination of many stochastic processes. Even for values bounded on a single side (i.e. greater than 0) the normal distribution may be accurate enough if the mean is &#34;far away&#34; from the bound of the scale measured in terms of standard deviations</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="LN">
        <xsd:annotation>
          <xsd:documentation>Log-Normal : The logarithmic normal distribution is used to transform skewed random variable X into a normally distributed random variable U = log X. The log-normal distribution can be specified with the properties mean  and standard deviation s. Note however that mean  and standard deviation s are the parameters of the raw value distribution, not the transformed parameters of the lognormal distribution that are conventionally referred to by the same letters. Those log-normal parameters  log and slog relate to the mean  and standard deviation s of the data value through slog2 = log (s2/2 + 1) and log = log  - slog2/2</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="G">
        <xsd:annotation>
          <xsd:documentation>? (gamma) : The gamma-distribution used for data that is skewed and bounded to the right, i.e. where the maximum of the distribution curve is located near the origin. The ?-distribution has two parameters a and . The relationship to mean  and variance s2 is  = a  and s2 = a 2</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="E">
        <xsd:annotation>
          <xsd:documentation>Exponential : Used for data that describes extinction. The exponential distribution is a special form of ?-distribution where a = 1, hence, the relationship to mean  and variance s2 are  =  and s2 = 2</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="X2">
        <xsd:annotation>
          <xsd:documentation>? : Used to describe the sum of squares of random variables that occurs when a variance is estimated (rather than presumed) from the sample. The only parameter of the ?2-distribution is ?, so called the number of degrees of freedom (which is the number of independent parts in the sum). The ?2-distribution is a special type of ?-distribution with parameter a = ? /2 and  = 2. Hence,  = ? and s2 = 2 ?</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="T">
        <xsd:annotation>
          <xsd:documentation>t (student) : Used to describe the quotient of a normal random variable and the square root of a ?2 random variable. The t-distribution has one parameter ?, the number of degrees of freedom. The relationship to mean  and variance s2 are:  = 0 and s2 = ? / (? - 2)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="F">
        <xsd:annotation>
          <xsd:documentation>F : Used to describe the quotient of two ?2 random variables. The F-distribution has two parameters ?1 and ?2, which are the numbers of degrees of freedom of the numerator and denominator variable respectively. The relationship to mean  and variance s2 are:  = ?2 / (?2 - 2) and s 2 = (2 ?22 (? 2 + ?1 - 2)) / (?1 (?2 - 2)2 (?2 - 4))</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="B">
        <xsd:annotation>
          <xsd:documentation>?(beta) : The beta-distribution is used for data that is bounded on both sides and may or may not be skewed (e.g., occurs when probabilities are estimated.) Two parameters a and  are available to adjust the curve. The mean  and variance s2 relate as follows:  = a / (a + ) and (s2 = a /((a + )2 (a +  + 1))</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Frame">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="void">
        <xsd:annotation>
          <xsd:documentation>Void : No sides</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="above">
        <xsd:annotation>
          <xsd:documentation>Above : The top side only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="below">
        <xsd:annotation>
          <xsd:documentation>Below : The bottom side only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="hsides">
        <xsd:annotation>
          <xsd:documentation>Hsides : The right and left sides only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="lhs">
        <xsd:annotation>
          <xsd:documentation>lhs : The left-hand side only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="rhs">
        <xsd:annotation>
          <xsd:documentation>rhs : The right-hand side only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="vsides">
        <xsd:annotation>
          <xsd:documentation>VSides : The top and bottom sides only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="box">
        <xsd:annotation>
          <xsd:documentation>Box : All four sides</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="border">
        <xsd:annotation>
          <xsd:documentation>Border : All four sides</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Rules">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="none">
        <xsd:annotation>
          <xsd:documentation>None : No rules.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="groups">
        <xsd:annotation>
          <xsd:documentation>Groups : Rules will appear between row groups  and column only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="rows">
        <xsd:annotation>
          <xsd:documentation>Rows : Rules will appear between rows only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="cols">
        <xsd:annotation>
          <xsd:documentation>Cols : Rules will appear between columns only</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="all">
        <xsd:annotation>
          <xsd:documentation>All : Rules will appear between all rows and columns</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Align">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="left">
        <xsd:annotation>
          <xsd:documentation>Left : The content is left aligned</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="center">
        <xsd:annotation>
          <xsd:documentation>Center : The content is center aligned</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="right">
        <xsd:annotation>
          <xsd:documentation>Right : The content is right aligned</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="justify">
        <xsd:annotation>
          <xsd:documentation>Justify : The content is justified</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="char">
        <xsd:annotation>
          <xsd:documentation>Char : align=char aligns a cell&#39;s contents on the character given in the char attribute. </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.VAlign">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="top">
        <xsd:annotation>
          <xsd:documentation>Top : The content is aligned with the top of the cell as shown in the caption column.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="middle">
        <xsd:annotation>
          <xsd:documentation>Middle : The content is aligned with the bottom of the cell as shown in the caption column.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="bottom">
        <xsd:annotation>
          <xsd:documentation>Bottom : The content is aligned with the bottom of the cell as shown in the caption column.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="baseline">
        <xsd:annotation>
          <xsd:documentation>Baseline : All cells in the same row as a cell whose valign attribute has this value should have their textual data positioned so that the first text line occurs on a baseline common to all cells in the row. This constraint does not apply to subsequent text lines in these cells</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.CellScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="row">
        <xsd:annotation>
          <xsd:documentation>Row : The current cell provides header information for the rest of the row that contains it</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="col">
        <xsd:annotation>
          <xsd:documentation>Col : The current cell provides header information for the rest of the column that contains it.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="rowgroup">
        <xsd:annotation>
          <xsd:documentation>Rowgroup : The header cell provides header information for the rest of the row group [p.116] that contains it.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="colgroup">
        <xsd:annotation>
          <xsd:documentation>Colgroup : The header cell provides header information for the rest of the column group [p.118] that contains it.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Revised">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="insert">
        <xsd:annotation>
          <xsd:documentation>Insert : This content was inserted in this revision of the document</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="delete">
        <xsd:annotation>
          <xsd:documentation>Delete : This content was deleted in this revision of the document</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.ListType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ordered" />
      <xsd:enumeration value="unordered" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Uid">
    <xsd:restriction base="xsd:string" />
  </xsd:simpleType>
  <xsd:simpleType name="Uri">
    <xsd:restriction base="xsd:anyURI" />
  </xsd:simpleType>
  <xsd:simpleType name="Code">
    <xsd:restriction base="xsd:string" />
  </xsd:simpleType>
  <xsd:complexType name="BL">
    <xsd:annotation>
      <xsd:documentation>BL stands for the values of two-valued logic. A BL value can be either true or false, or may have a nullFlavor.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value if not nullFlavored">
          <sch:rule abstract="true" id="BL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="value" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>The value of the BL.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ANY">
    <xsd:annotation>
      <xsd:documentation>Defines the basic properties of every data value. This is conceptually an abstract type, meaning that no proper value can be just a data value without belonging to any concrete type. Every public concrete type is a specialization of this general abstract DataValue type. 

However exceptional values (nullFlavored values) may be of type ANY, except for the exceptional values that imply the nullFlavor INV, since this requires a type to be meaningful. Note that not all nullFlavors may be used with the type ANY (see section 7.1.4 for more details)</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="no ANY unless nullFlavored">
          <sch:rule abstract="true" id="ANY-0">
            <sch:assert test="not(@xsi:type) or (xsi:type != &#34;ANY&#34;) or (@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="HXIT">
        <xsd:attribute name="nullFlavor" type="NullFlavor" use="optional">
          <xsd:annotation>
            <xsd:documentation>If the value is not a proper value, indicates the reason.

Though the nullFlavor concept has some relationship with the UML/OCL null, it is not the same thing, and the relationship and differences between the two must be understood to properly implement this specification. For further discussion, see section 7.1.4 (Null and NullFlavor). Note that nullFlavor includes the concept of a UML null value, and also includes potentially fully populated instances that do not conform to the requirements placed on the instance (also known as &#34;exceptional instances&#34;). Both nonNull and nullFlavored values SHALL always be valid according to the rules expressed in this specification.

If populated, the value of this attribute SHALL be taken from the HL7 NullFlavor code system. </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="flavorId" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>Signals the imposition of one or more sets of constraints on the datatype. The sole purpose of specifying that a constraint that has been used to further constrain the datatype is to support validation of the instance: a validation engine can look up the rules expressed for the specified flavors and confirm that the instance conforms to the rules for the flavor. No other processing should depend on the content of the flavor attribute&#60;b&#62;. &#60;/b&#62;

No other semantic or computational use SHALL depend on the value of this property. If this value is populated, the datatype flavor(s) SHALL be a valid constraint on the type of the value. 

There is further discussion about the use of Data Type flavors and flavorId in section A.3</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="updateMode" type="UpdateMode" use="optional">
          <xsd:annotation>
            <xsd:documentation>This property allows a sending system to identify the role that the attribute plays in processing the instance that is being represented.

If populated, the value of this attribute SHALL be taken from the HL7 UpdateMode code system.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="HXIT">
    <xsd:annotation>
      <xsd:documentation>Information about the history of this value: period of validity and a reference to an identified event that established this value as valid.

Because of the way that the types are defined, a number of attributes of the datatypes have values with a type derived from HXIT. In these cases the HXIT attributes are constrained to null. The only case where the HXIT attributes are allowed within a datatype is on items in a collection (DSET, LIST, BAG, HIST).
The use of these attributes is generally subject to further constraints in the specifications that make use of these types.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="extension requires root">
          <sch:rule abstract="true" id="HXIT-0">
            <sch:assert test="not(@controlInformationExtension) or @controlInformationRoot" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="validTimeLow" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The time that the given information became or will become valid. 

This is not the time that any system first observed the value, but the time that the actual value became correct (i.e. when a patient changes their name).</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="validTimeHigh" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The time that the given information ceased or will cease to be correct.

Both validTimeLow and validTimeHigh must be valid timestamps using the format described in  7.8.12.3.1 (TS.value). </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="controlInformationRoot" type="Uid" use="optional">
      <xsd:annotation>
        <xsd:documentation>The root of the identifier of the event associated with setting the datatype to its specified value. </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="controlInformationExtension" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The extension of the identifier of the event associated with setting the datatype to its specified value.

Together, the root and extension identify a particular record of a real world event that may supply additional information about the value such as who made the change, when it was made, why it was made, what system originated the change. These attributes exist because sometimes this information is required, but the value is being represented in an external context that does not contain a proper relationship to the control information for the value itself. The record need not be directly or easily resolvable. Conformance statements may make additional statements about these two properties, or about how such a reference should be resolved.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="ED">
    <xsd:annotation>
      <xsd:documentation>Data that is primarily intended for human interpretation or for further machine processing outside the scope of this specification. This includes unformatted or formatted written language, multimedia data, or structured information as defined by a different standard (e.g., XML-signatures.) 
Encapsulated data can be present in two forms, inline or by reference. The content is the same whether it is located inline or remote.Inline data is communicated or moved as part of the encapsulated data value, whereas by-reference data may reside at a different  location: a URL/URI that provides reference to the information required to locate the data. Inline data may be provided in one of 3 different ways:
&#60;ul&#62;
	&#60;li&#62;as a plain sequence of characters (value)&#60;/li&#62;
	&#60;li&#62;as a binary (a sequence of bytes) (data)&#60;/li&#62;
	&#60;li&#62;as xml content (xml)&#60;/li&#62;
&#60;/ul&#62;
Content SHALL be provided if the ED has no nullFlavor. The content may be provided in-line (using only one of value, data or xml), or it may be provided as a reference.Content may be provided in-line and a reference also may be given; in these cases, it is expected that the content of the reference will be exactly the same as the in-line content. Information Processing Entities are not required to check this, but may regard it as an error condition if the content does not match</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="content is required if not null">
          <sch:rule abstract="true" id="ED-0">
            <sch:assert test="@nullFlavor or @value or xml or data" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="only one of value, data, xml">
          <sch:rule abstract="true" id="ED-1">
            <sch:assert test="count(*[self::value or self::xml or self::data])&#60;=1" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="integrityCheckAlgorithm required">
          <sch:rule abstract="true" id="ED-2">
            <sch:assert test="not(integrityCheck) or @integrityCheckAlgorithm" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not use reference">
          <sch:rule abstract="true" id="ED-3">
            <sch:assert test="not(thumbnail) or thumbnail[not(@nullFlavor and reference)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not have thumbnails">
          <sch:rule abstract="true" id="ED-4">
            <sch:assert test="not(thumbnail) or thumbnail[not(thumbnail)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="compression only on binary">
          <sch:rule abstract="true" id="ED-5">
            <sch:assert test="(@compression and data) or not(@compression or data)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="mediaType cannot be null">
          <sch:rule abstract="true" id="ED-6">
            <sch:assert test="@mediaType" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value implies mediaType is text/plain">
          <sch:rule abstract="true" id="ED-7">
            <sch:assert test="not(@value) or (@value and (not(@mediaType) or @mediaType=&#39;text/plain&#39;))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no charset for value or xml">
          <sch:rule abstract="true" id="ED-8">
            <sch:assert test="not(@value or xml) or not(@charset)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="ED-9">
            <sch:assert test="count(*[self::reference or self::thumbnail][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ED-10">
            <sch:assert test="not(translation) or thumbnail[not(translation)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="reference: no use">
          <sch:rule abstract="true" id="ED-11">
            <sch:assert test="not(reference) or (not(reference/use))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="reference: schemes">
          <sch:rule abstract="true" id="ED-12">
            <sch:assert test="not(reference) or ((starts-with(reference/@value, &#34;file&#34;) or starts-with(reference/@value, &#34;ftp&#34;) or starts-with(reference/@value, &#34;http&#34;) or starts-with(reference/@value, &#34;https&#34;) or starts-with(@value, &#34;nfs&#34;)))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A simple sequence of byte values that contains the content.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The content represented in plain XML form.

A direct representation is provided for XML. This is because this specification includes an XML serialization of the data, and this xml attribute is handled specially in the serialisation form. The xml data is not different in any semantic sense to the same data if represented in the value or data attributes.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="reference" type="TEL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A URL the target of which provides the binary content.

The semantic value of an encapsulated data value is the same, regardless whether the content is present as inline content or just by reference. However, an encapsulated data value without inline content behaves differently, since any attempt to examine the content requires the data to be downloaded from the reference. An encapsulated data value may have both inline content and a reference.

If data is provded in the value, data or xml attributes, the reference SHALL point to the same data. It is an error if the data resolved through the reference does not match either the integrity check, data as provided, or data that had earlier been retrieved through the reference and then cached. The mediatype of the ED SHALL match the type returned by accessing the reference. 

The reference may contain a usablePeriod to indicate that the data may only be available for a limited period of time. Whether the reference is limited by a usablePeriod or not, the content of the reference SHALL be fixed for all time. Any application using the reference SHALL always receive the same data, or an error. The reference cannot be reused to send a different version of the same data, or different data</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A checksum calculated over the binary data

The purpose of this property, when communicated with a reference is for anyone to validate later whether the reference still resolved to the same content that the reference resolved to when the encapsulated data value with reference was created. If the attribute is null, there is no integrityCheck.
It is an error if the data resolved through the reference does not match the integrity check. 
The integrity check is calculated according to the integrityCheckAlgorithm. By default, the Secure Hash Algorithm-1 (SHA-1) shall be used. The integrity check is binary encoded according to the rules of the integrity check algorithm. 
The integrity check is calculated over the raw binary data that is contained in the data component, or that is accessible through the reference. No transformations are made before the integrity check is calculated. If the data is compressed, the Integrity Check is calculated over the compressed data. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>An abbreviated rendition of the full content. 

A thumbnail requires significantly fewer resources than the full content, while still maintaining some distinctive similarity with the full content. A thumbnail is typically used with by-reference encapsulated data. It allows a user to select the appropriate content more efficiently before actually downloading through the reference.

Originally, the term thumbnail refers to an image in a lower resolution (or smaller size) than another image. However, the thumbnail concept can be metaphorically used for media types other than images. For example, a movie may be represented by a shorter clip; an audio-clip may be represented by another audio-clip that is shorter, has a lower sampling rate, or a lossy compression; or an abstract provided for a long document.

A thumbnail itself SHALL NOT contain a thumbnail.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>An alternative description of the media where the media is not able to be rendered. 

E.g. Short text description of an image or sound clip, etc. This attribute is not intended to be a complete substitute for the original. For complete substitutes, use the &#34;translation&#34; property.

The intent of this property is to allow compliance with disability requirements such as those expressed in American&#39;s with Disability Act (also known as &#34;Section 508&#34;), where there is a requirement to provide a short text description of included media in some form that can be read by a screen reader. This is similar to a very short thumbnail with mediaType = text/plain.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Alternate renditions of the same content translated into a different language or a different mediaType. 
The translations SHALL convey the same information, but in a different language or mediaType. Translations SHALL not contain translations. The translations do not take part in the test for equality, so SHALL NOT introduce any new semantics to the value.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>A simple sequence of characters that contains the content. 

If value is used, the mediatype is fixed to text/plain and the charset must be consistent with the String Character Set. Refer to section 6.7.5 for more details</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="mediaType" type="xsd:string" default="text/plain" use="optional">
          <xsd:annotation>
            <xsd:documentation>Identifies the type of the encapsulated data and can be used to determine a method to interpret or render the content. 

The IANA defined domain of media types is established by the IETF RFCs 2045 and 2046. mediaType has a default value of text/plain and cannot be null. If the media type is different to text/plain, the &#60;i&#62;mediaType&#60;/i&#62; attribute SHALL be populated.

If the content is compressed using a specified compression algorithm, the mediaType SHALL refer the mediaType of the uncompressed data, whether the data is accessed by reference or not. </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="charset" type="Code" use="optional">
          <xsd:annotation>
            <xsd:documentation>An Internet Assigned Numbers Authority (IANA) Charset Registered character set and character encoding for character-based encoding types&#60;b&#62;. &#60;/b&#62;

Whenever the content of the ED is character type data in any form, the charset property needs to be known. If the content is provided directly in the value attribute, then the charset SHALL be a known character set consistent with the String Character Set. Refer to section 6.7.5 for more details. If the content is provided as a reference, and the access method does not provide the charset for the content (such as by a mime header), then the charset SHALL be conveyed as part of the ED</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="language" type="Code" use="optional">
          <xsd:annotation>
            <xsd:documentation>The human language of the content. Valid codes are taken from the IETF RFC 3066. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.

Conformance profiles SHOULD define defaulting rules for language for a given usage environment of this specification.

Note: While language attribute usually alters the interpretation of the text, the language attribute does not alter the meaning of the characters in the text.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="compression" type="Compression" use="optional">
          <xsd:annotation>
            <xsd:documentation>The compression algorithm, if any, used on the raw byte data.

If the attribute is null, the data is not compressed. Compression only applies to the binary form of the content.

If populated, the value of this attribute SHALL be taken from the HL7 CompressionAlgorithm code system.

Some compression formats allow multiple archive files to be embedded within a single compressed volume. Applications SHALL ensure that the decompressed form of the data conforms to the stated media type</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="integrityCheckAlgorithm" type="IntegrityCheckAlgorithm" use="optional">
          <xsd:annotation>
            <xsd:documentation>The algorithm used to compute the integrityCheck value.
If populated, the value of this attribute SHALL be taken from the HL7 IntegrityCheckAlgorithm code system.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL">
    <xsd:annotation>
      <xsd:documentation>A locatable resource that is identified by a URI, such as a web page, a telephone number (voice, fax or some other resource mediated by telecommunication equipment), an e-mail address, or any other locatable resource that can be specified by a URL.

The address is specified as a Universal Resource Locator (URL) qualified by time specification and use codes that help in deciding which address to use for a given time and purpose.

The value attribute is constrained to be a uniform resource locator specified according to IETF RFCs 1738 and 2806 when used in this datatype. 

Note:  The intent of this datatype is to be a locator, not an identifier; this datatype is used to refer to a locatable resource using a URL, and knowing the URL allows one to locate the object. However some use cases have arisen where a URI is used to refer to a locatable resource. Though this datatype allows for URIs to be used, the resource identified SHOULD always be locatable. A common use of locatable URI&#39;s is to refer to SOAP attachments.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="TEL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on TEL attributes">
          <sch:rule abstract="true" id="TEL-1">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The periods of time during which the telecommunication address can be used. 

For a telephone number, this can indicate the time of day in which the party can be reached on that telephone. For a web address, it may specify a time range in which the web content is promised to be available under the given address.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:anyURI" use="optional">
          <xsd:annotation>
            <xsd:documentation>A uniform resource identifier specified according to IETF RFC 2396. 

The URI specifies the protocol and the contact point defined by that protocol for the resource. 

Examples:  Notable uses of the telecommunication address datatype are for telephone and telefax numbers, e-mail addresses, Hypertext references, FTP references, etc.

If the TEL has a nullFlavor, it is not necessary for the value to contain a valid URL. For instance, if the flavor is UNK, the value may be just &#34;tel:&#34; to indicate that what is unknown is a telephone number.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="use" type="set_TelecommunicationAddressUse" use="optional">
          <xsd:annotation>
            <xsd:documentation>One or more codes advising system or user which telecommunication address in a set of like addresses to select for a given telecommunication need. 

The telecommunication use code is not a complete classification for equipment types or locations. Its main purpose is to suggest or discourage the use of a particular telecommunication address. There are no easily defined rules that govern the selection of a telecommunication address. Conformance statements may clarify what rules may apply or how additional rules are applied.

If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationAddressUse code system</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="capabilities" type="set_TelecommunicationCapability" use="optional">
          <xsd:annotation>
            <xsd:documentation>One or more codes advising a system or user what telecommunication capabilities are known to be associated with the telecommunication address. 

If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationCapability code system</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS">
    <xsd:annotation>
      <xsd:documentation>Abstract; specializes ANY

Parameter: T : QTY

An unordered set of distinct values which are quantities. 

Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).

QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).

QSETs SHALL not contain null or nullFlavored values as members of the set.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the &#60;i&#62;QSET&#60;/i&#62; is not valid, then the &#60;i&#62;QSET&#60;/i&#62; SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ST">
    <xsd:annotation>
      <xsd:documentation>The character string datatype stands for text data, primarily intended for machine processing (e.g., sorting, querying, indexing, etc.) or direct display. Used for names, symbols, presentation and formal expressions.

A ST SHALL have at least one character or else have a nullFlavor</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ST-0">
            <sch:assert test="not(translation) or thumbnail[not(translation)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="content if not null">
          <sch:rule abstract="true" id="ST-1">
            <sch:assert test="(@nullFlavor or (@value and string-length(@value)&#38;gt;0)) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="translation: no translations">
          <sch:rule abstract="true" id="ST-2">
            <sch:assert test="not(translation) or (not(translation/translation))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="translation" type="ST" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Alternate renditions of the same content translated into a different language. Translations may not contain translations.

While Language tags usually alter the meaning of the text, the language does not alter the meaning of the characters in the text.

Note: add a note that language is often defaulted to context </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>The actual content of the string. Refer to section 6.7.5 for discussion on String character encodings.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="language" type="Code" use="optional">
          <xsd:annotation>
            <xsd:documentation>The human language of the content. Valid codes are taken from the IETF RFC 3066. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.
Note: While Language tags usually alter the meaning of the text, the language does not alter the meaning of the characters in the text.
Note: add a note that language is often defaulted to context </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SC">
    <xsd:annotation>
      <xsd:documentation>A character string that optionally may have a code attached. The text must always be present if a code is present. 

The code is often a local code. SC is used in cases where coding is exceptional (e.g., user error messages are essentially text messages, and the text message is the important content. However sometimes messages come from a catalog of prepared messages, which SC allows to reference).

Any non-null SC value MAY have a code, however, a code SHALL NOT be given without the text. 

The similarities and differences between SC and CD are discussed in Section  7.5.1.2, CD and SC</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="no code if no value">
          <sch:rule abstract="true" id="SC-0">
            <sch:assert test="not(@nullFlavor) or (not(code) or (code/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SC attributes">
          <sch:rule abstract="true" id="SC-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="SC-2">
            <sch:assert test="(not(originalText) or not(oroginalText/@nullFlavor)) or (not(code) or (code/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ST">
        <xsd:sequence>
          <xsd:element name="code" type="CD" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The coded value associated with the string. If the value is or nullFlavored, there is no coded value associated with this string. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CD">
    <xsd:annotation>
      <xsd:documentation>A &#60;i&#62;CD&#60;/i&#62; is a reference to a concept defined in an external code system, terminology, or ontology. A &#60;i&#62;CD&#60;/i&#62; may contain a simple code - that is, a reference to a concept defined directly by the referenced code system, or it may contain an expression in some syntax defined by the referenced code system that can be meaningfully evaluated. e.g., the concept of a &#34;left foot&#34; as a postcoordinated term built from the primary code &#34;FOOT&#34; and the qualifier &#34;LEFT&#34;. 

A CD may also contain an original text or phrase that served as the basis of the coding. This is preserved to allow for validation of the representation of the concept in various fashions. 

A CD can contain one or more translations into multiple coding systems. The translations are all representations of the same concept in various code systems. There is only one concept, and only the first CD may contain an original text. It is possible to represent the translation chain - which CD was translated from which - if desired. Each CD may also carry a rationale to indicate why it is represented.

A CD with no nullFlavor attribute SHALL have a code attribute or nonNull originalText attribute. A CD that has a code, codeSystem or originalText attribute but does not meet external constraints of the applicable value set SHALL have a nullFlavor attribute with a value of &#34;OTH&#34;.

Attributes with type CD are generally bound by externally specified constraints which constrain the coded concepts to which a CD may refer. These constraints may be qualified as &#34;extensible&#34; (CWE) or &#34;not extensible&#34; (CNE). If the constraint is not extensible (CNE), then a the CD that does not have a nullFlavor SHALL contain a code that conforms to the constraint. If the constraint is extensible (CWE) then a CD that does not have a nullFlavor SHALL contain either a code that exists in the domain with which the attribute is associated, a code from a locally defined code system, or just some originalText that describes the concept. If the code is taken from a locally defined code system, then the codeSystem property SHALL specify the local code system.
For both CNE and CWE constraint types, the translations may contain nonNull codes from any source unless otherwise specified by the constraining model. 

For code systems that define expression syntaxes, CNE constraints may be used, providing that the code system definitions define the appropriate support to enable value sets to make useful statements about how to control the expression syntax, and that the value set machinery used also has the appropriate support</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null or code and/or originalText">
          <sch:rule abstract="true" id="CD-0">
            <sch:assert test="@nullFlavor or @code or (originalText and not(originalText/@nullFlavor) or (originalTextReference and not(originalTextReference/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="other requires codeSystem or valueSet">
          <sch:rule abstract="true" id="CD-1">
            <sch:assert test="@nullFlavor != &#34;OTH&#34; or @codeSystem or @valueSet" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="CD-2">
            <sch:assert test="@codeSystem or not(@code)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemName only if codeSystem">
          <sch:rule abstract="true" id="CD-3">
            <sch:assert test="@codeSystem or not(@codeSystemName)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="CD-4">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="displayName only if code">
          <sch:rule abstract="true" id="CD-5">
            <sch:assert test="@code or not(@displayName)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="valueSet requires valueSetVersion">
          <sch:rule abstract="true" id="CD-6">
            <sch:assert test="not(@valueSet) or (@valueSet and @valueSetVersion)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No original text on translations">
          <sch:rule abstract="true" id="CD-7">
            <sch:assert test="not translation/originalText" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="Translations cannot have translations">
          <sch:rule abstract="true" id="CD-8">
            <sch:assert test="not translation/translation" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on CD elements">
          <sch:rule abstract="true" id="CD-9">
            <sch:assert test="count(*[self::displayName or self::originalText or self::originalTextReference or self::translation][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="displayName" type="ST" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A name, title, or representation for the code or expression as it exists in the code system.

If populated, the displayName SHALL be a valid human readable representation of the concept as defined by the code system at the time of data entry. The displayName SHALL conform to any rules defined by the codingSystem; if the codeSystem does not define a human representation for the code or expression, then none can be provided. displayName is included both as a courtesy to an unaided human interpreter of a code value and as a documentation of the name used to display the concept to the user. The display name has no functional meaning; it SHALL never exist without a code; and it SHALL never modify the meaning of the code. A display name may not be present if the code is an expression for which no display name has been assigned or can be derived. Information Processing Entities claiming direct or indirect conformance MAY choose not to implement displayName but SHALL NOT reject instances because displayName is present.

Display names SHALL not alter the meaning of the code value. Therefore, display names SHOULD NOT be presented to the user on a receiving application system without ascertaining that the display name adequately represents the concept referred to by the code value. Communication SHALL NOT simply rely on the display name. The display name&#39;s main purpose is to support implementation debugging.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text as seen and/or selected by the user who entered the data which represents the intended meaning of the user. 

Note: Local implementations may influence what is required to represent that original text.

Original text can be used in a structured user interface to capture what the user saw as a representation of the code on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use the CD datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a code. In a situation where the code is assigned sometime after the text was entered, originalText is the text or phrase used as the basis for assigning the code. 

The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Values of type CD MAY have a original text despite not having a code. Any CD value with no code signifies a coding exception. In this case, originalText is a name or description of the concept that was not coded. Such CD values MAY also contain translations. 

Translations directly encode the concept described in originalText. The originalText represents the originalText of the concept itself. Translations SHALL NOT have an originalText of their own.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A set of other CDs that each represent a translation of this CD into equivalent codes within the same code system or into corresponding concepts from other code systems.

The translations are quasi-synonyms of one real-world concept. Every translation in the set is supposed to express the same meaning &#34;in other words.&#34; However, exact synonymy rarely exists between two structurally different coding systems. For this reason, not all of the translations will be equally exact. 
Translations SHALL NOT contain translations. The root CD has one set of translations which lists all the translations. The root translation is generally the one that best meets the conformance criteria for the CD. No implication about lineage of the translations can be drawn from the selection of the root code. Instead the properties codingRationale and source is used to trace lineage. 
In the absence of a constraining model that makes constraints on the value domain of the CD, any of the translations MAY be the root CD. If the constraining model makes constraints on the value domain of the CD and there is a translation that meets the constraints, that translation SHOULD be the root CD. If the constraining model makes constraints on the value domain of the CD and there is no translation that meets the constraints, then any of the translations MAY be the root, as long as they are assigned a nullFlavor. An alternative is to put none of the translations in the root, and give it a nullFlavor of choice, and put all the translations in the translation property of the root. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="source" type="XReference" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A reference to the CD that was the source of this translation, if this CD was created by translating it from another CD. 

This property is a reference. The source to which the reference points SHALL be provided within the scope of this CD&#39;s root CD and translations; that is, another representation of the same concept in the same attribute.

A CD consists of a single root code and a set of translations, which do not have translations. Using the codingRationale property, a sender can indicate which is the original code. There are some circumstances in which it is useful to know which CD was translation from which CD. The source allows for the translation sequence from one translation to another to be represented. Each element of the translation set was translated from the original CD. Each translation may, however, also have further translations. Thus, when a code is translated multiple times the information about which code served as the input to which translation will be preserved</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="code" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>The plain code symbol defined by the code system, or an expression in a syntax defined by the code system which describes the concept. 
If a code is provided, it SHALL be an exact match to a plain code symbol or expression defined by the code system. If the code system defines a code or expression that includes whitespace, the code SHALL include the whitespace. An expression can only be used where the codeSystem either defines an expression syntax, or there is a generally accepted syntax for the codeSystem. A code system may be defined that only defines an expression syntax with bindings to other code Systems for the elements of the expression. 
 It is at the discretion of the interpreting system whether to check for an expression instead of a simple code and evaluate the expression instead of treating the expression as a code. In some cases, it may be unclear or ambiguous whether the code represents a single symbol or an expression. This usually arises where the code system defines an expression language and then defines pre-coordinated concepts with symbols which match their expression, e.g. UCUM. In other cases, it is safe to treat the expression as a symbol. There is no guarantee that this is always safe: the definitions of the codeSystem should always be consulted to determine how to handle potential expressions. 
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="codeSystem" type="Uid" use="optional">
          <xsd:annotation>
            <xsd:documentation>The code system that defines the code, or if no code was found, the codeSystem in which no code was found. 
Code systems SHALL be referred to by a UID, which allows unambiguous reference to standard code systems and other local codesystems. Where either ISO or HL7 have assigned UID to code Systems, then these UIDs SHALL be used. Otherwise implementations SHALL use an appropriate ISO Object Identifier (OID) or UUID to construct a globally unique local coding system identifier.
A CD that has a code attribute SHALL have a codeSystem specifying the system of concepts that defines the code.
An CD with a nullFlavor OTH indicates that a concept could not be coded in the coding system or value set specified. Thus, for these coding exceptions, the code system or value set that did not contain the appropriate concept SHALL be provided in codeSystem or valueSet.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="codeSystemName" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>The common name of the coding system. 

The code system name has no computational value. codeSystemName can never modify the meaning of codeSystem and cannot exist without codeSystem.

Information Processing Entities claiming direct or indirect conformance SHALL NOT functionally rely on &#60;i&#62;codeSystemName&#60;/i&#62;. In addition, they MAY choose not to implement &#60;i&#62;codeSystemName&#60;/i&#62; but SHALL NOT reject instances because &#60;i&#62;codeSystemName&#60;/i&#62; is present.

Note:  The purpose of a code system name is to assist an unaided human interpreter of a code value to interpret codeSystem.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>If applicable, a version descriptor defined specifically for the given code system.

Different versions of one code system must be compatible. By definition a code symbol SHALL have the same meaning throughout all versions of a code system. Between versions, codes may be retired but not withdrawn or reused. Where the definition of the meaning of a code symbol changes, it must still be compatible (equal) between different code system versions.

Whenever a code system changes in an incompatible way, it will constitute a new code system, not simply a different version, regardless of how the vocabulary publisher calls it. For example, the publisher of ICD-9 and ICD-10 calls these code systems, &#34;revision 9&#34; and &#34;revision 10&#34; respectively. However, ICD-10 is a complete redesign of the ICD code, not a backward compatible version. Therefore, for the purpose of this datatype specification, ICD-9 and ICD-10 are different code systems, not just different versions. By contrast, when LOINC updates from revision &#34;1.0j&#34; to &#34;1.0k&#34;, this would be considered as just another version of LOINC, since LOINC revisions are backwards compatible.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="valueSet" type="Uid" use="optional">
          <xsd:annotation>
            <xsd:documentation>The value set that applied when this CD was created.

Value sets shall be referred to by an identifier name which allows unambiguous reference to a value set. Where either ISO or HL7 have assigned an identifying name to a value set, then that name shall be used. 

In many cases, a CD is created from a value set - either a code/code system pair is chosen from a valueSet, or one is not chosen and the CD has the exceptional value of NullFlavor.OTH. If no code is chosen, it is generally inappropriate to reference the code system from which the code was chosen as the value set may not match the code system (may include a subset of the codeSystem, or additional terms from other code systems); instead, the value set should be provided. In addition, there are some known use cases where the value set that a user or system was offered when choosing a code affects the interpretation of the code. 

If a code is provided, the meaning of the code must come from the definition of the code in the code system. The meaning of the code SHALL NOT depend on the value set. Information Processing Entities claiming direct or indirect conformance SHALL NOT be required to interpret the code in light of the valueSet, and they SHALL NOT reject an instance because of the presence or absence of any or a particular value set. </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="valueSetVersion" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>The version of the valueSet in which no code was found.

&#60;i&#62;valueSetVersion&#60;/i&#62; SHALL be provided when a valueSet is provided, and otherwise SHALL be null. The value of the &#60;i&#62;valueSetVersion&#60;/i&#62; must properly identify a particular version of the value set following the rules defined by the value set or its publisher. 

It is generally recommended that value set publishers specify that the version is identified by the date/time that the value set version is published, and that the publication process makes the date/time explicitly clearclear.  </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="codingRationale" type="CodingRationale" use="optional">
          <xsd:annotation>
            <xsd:documentation>the reason why a particular &#60;i&#62;CD&#60;/i&#62; has been provided, either as the root concept or as one of the translations.

If populated, the value contained in this attribute SHALL be taken from this enumeration, composed from the HL7 CodingRationale code system</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="xsd:ID" use="optional">
          <xsd:annotation>
            <xsd:documentation>This is the target for a reference from a source</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="XReference">
    <xsd:attribute name="xref" type="xsd:IDREF" use="required" />
  </xsd:complexType>
  <xsd:complexType name="II">
    <xsd:annotation>
      <xsd:documentation>An identifier that uniquely identifies a thing or object. 

Examples are object identifier for HL7 RIM objects, medical record number, order id, service catalog item id, Vehicle Identification Number (VIN), etc. Instance identifiers are usually defined based on ISO object identifiers.

An identifier allows someone to select one record, object or thing from a set of candidates. Usually an identifier alone without any context is not usable. Identifiers are distinguished from concept descriptors as concept descriptors never identify an individual thing, although there may sometimes be an individual record or object that represents the concept.

Information Processing Entities claiming direct or indirect conformance SHALL never assume that receiving applications can infer the identity of issuing authority or the type of the identifier from the identifier or components thereof.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="root is required">
          <sch:rule abstract="true" id="II-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @root)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="root" type="Uid" use="optional">
          <xsd:annotation>
            <xsd:documentation>A unique identifier that guarantees the global uniqueness of the instance identifier. 

If root is populated, and there is no nullFlavor or extension, then the root is a globally unique identifier in it&#39;s own right. In the presence of a non-null extension, the root is the unique identifier for the &#34;namespace&#34; of the identifier in the extension. Note that this does NOT necessarily correlate with the organization that manages the issuing of the identifiers. A given organization may manage multiple identifier namespaces, and control over a given namespace may transfer from organization to organization over time while the root remains the same. 

This field can be either a DCE UUID, an Object Identifier (OID), or a special identifier taken from lists that may be published by ISO or HL7. 

Comparison of root values is always case sensitive. UUID&#39;s SHALL be represented in upper case, so UUID case should always be preserved. 

The root SHALL not be used to carry semantic meaning - all it does is ensure global computational uniqueness</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="extension" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>A character string as a unique identifier within the scope of the identifier root. 

The root and extension scheme means that the concatenation of root and extension SHALL be a globally unique identifier for the item that this II value identifies.

Some identifier schemes define certain style options to their code values. For example, the U.S. Social Security Number (SSN) is normally written with dashes that group the digits into a pattern &#34;123-12-1234&#34;. However, the dashes are not meaningful and a SSN can also be represented as &#34;123121234&#34; without the dashes. In the case where identifier schemes provide for multiple representations, HL7 or ISO may make a ruling about which is the preferred form and document that ruling where that respective external identifier scheme is recognized.

If no&#60;i&#62; extension&#60;/i&#62; attribute is provided in a non-null &#60;i&#62;II&#60;/i&#62;, then the root is the complete unique identifier. If the root is not a complete unique identifier, and the extension is not known, then the &#60;i&#62;II&#60;/i&#62;  SHALL have a nullFlavor even if the root is populated.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="identifierName" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>This is a human-readable name for the namespace represented in the root. 

Note:  It is a descriptive name for the actual namespace. e.g. &#34;California, U.S. Driver&#39;s License Number, 1970-&#34;.

IdentifierName does NOT refer to the organization which issued the identifier (e.g. California Dept. of Motor Vehicles). It is intended for use as a human readable label when an identifier must be displayed to a human user where an OID would not be meaningful. 

The Identifier Name has no computational value. IdentifierName can never modify the meaning of the root attribute. The purpose of the Identifer Name is to assist an unaided human interpreter of an II value to interpret the authority. Applications SHALL NOT attempt to perform any decision-making, matching, filtering or other processing based on the presence or value of this property. It is for display and development assistance only. All decision logic MUST be based solely on the root and extension properties. Information Processing Entities claiming direct or indirect conformance MAY choose not to implement &#60;i&#62;identifierName&#60;/i&#62; but SHALL NOT reject instances because &#60;i&#62;identifierName&#60;/i&#62; is present.

Note: In general, it should only be used when an extension is present, allowing for a display such as &#34;California, U.S. Driver&#39;s License Number, 1970-: 123456789&#34;. There are absolutely no guidelines for the contents of this text other than it should be completely descriptive of the namespace. E.g. &#34;Driver&#39;s License&#34; or even &#34;California Driver&#39;s License&#34; would not be ideal. However, formatting, capitalization, whitepace, language, etc. are completely up to the sender.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="displayable" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>If the identifier is intended for human display and data entry (displayable = true) as opposed to pure machine interoperation (displayable = false).
Information Processing Entities claiming direct or indirect conformance MAY choose not to implement displayable but SHALL NOT reject instances because displayable is present.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="scope" type="IdentifierScope" use="optional">
          <xsd:annotation>
            <xsd:documentation>The scope in which the identifier applies to the object with which it is associated.
If populated, the value of this attribute SHALL be taken from the HL7 IdentifierScope code system</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="reliability" type="IdentifierReliability" use="optional">
          <xsd:annotation>
            <xsd:documentation>The reliability with which this identifier is known. This attribute may be used to assist with identifier matching algorithms.
If populated, the value of this attribute SHALL be taken from the HL7 IdentifierReliability code system.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CO">
    <xsd:annotation>
      <xsd:documentation>Represents data where coded values are associated with a specific order. 
Note:  CO may be used for things that model rankings and scores, e.g. likert scales, pain, Apgar values, etc, where there is a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite. CO may also be used in the context of an ordered code system. In this case, it may not be appropriate or even possible to use the value attribute, but CO may still be used so that models that make use of such code systems may introduce model elements that involve statements about the order of the terms in a domain.
The relative order of values in a code system need not be independently obvious in the literal representation of the CO. It these circumstances, is expected that an application will look up the ordering of these values from some definition of the code system. 
Some of the code systems will directly assign numerical value to the concepts that are suitable for some mathemetical operations.
Though it would generally make sense, applications SHOULD not assume that the translations of the code, if provided, will have the same ordering as the CO. Translations SHALL not be considered when the ordering of the code system is determined.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have a code or a value">
          <sch:rule abstract="true" id="CO-0">
            <sch:assert test="@nullFlavor or (@value or (code and not(code/@nullFlavor)))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="CO-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="uncertainty Type">
          <sch:rule abstract="true" id="CO-2">
            <sch:assert test="@xsi:type = &#34;REAL&#34;" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="code" type="CD" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A code representing the definition of the ordinal item</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="value" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>A numerical value associated with the coded ordinal value.
The value may be constrained to an integer in some contexts of use. If code is nonNull, value SHALL only be nonNull if the code system explicitly assigns a value to the concept.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QTY">
    <xsd:annotation>
      <xsd:documentation>The quantity datatype is an abstract generalization for all datatypes whose domain values has an order relation (less-or-equal) and where difference is defined in all of the datatype&#39;s totally ordered value subsets. 

The quantity type abstraction is needed in defining certain other types, such as the interval, and probability distributions.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="uncertainty rules">
          <sch:rule abstract="true" id="QTY-0">
            <sch:assert test="not(uncertainty/@expression) and not(uncertainty/@uncertainty) and not(uncertainty/@uncertainRange) and not(uncertainty/@originalText)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="uncertainRange rules">
          <sch:rule abstract="true" id="QTY-1">
            <sch:assert test="not(uncertainRange/low/@expression) and not(uncertainRange/low/@uncertainty) and not(uncertainRange/low/@uncertainRange) and not(uncertainty/low/@originalText) and not(uncertainRange/high/@expression) and not(uncertainRange/high/@uncertainty) and not(uncertainRange/high/@uncertainRange) and not(uncertainty/high/@originalText)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="uncertainty kind">
          <sch:rule abstract="true" id="QTY-2">
            <sch:assert test="not(uncertainty) or not(uncertainRange)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="uncertainRange Type">
          <sch:rule abstract="true" id="QTY-3">
            <sch:assert test="not(uncertainRange) or (not(uncertainRange/width) and not(uncertainRange/any) and ((uncertainRange/low and not(uncertainRange/low/@nullFlavor)) or (uncertainRange/high  and not(uncertainRange/high/@nullFlavor)))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QTY-4">
            <sch:assert test="count(*[self::originalText or self::uncertainty or self::uncertainRange or self::expression][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>An expression that can be used to derive the actual value of the quantity given information taken from the context of use.

For example expression can be used for expressing dosage instructions that depend on patient body weight. 

If no proper value is provided for the QTY, then the value SHALL have a nullFlavor, whether or not an expression is provided. If no proper value is provided, and an expression is provided, the appropriate nullFlavor is usually DER. No nullFlavor is required if both a proper value and an expression is provided; in such cases, it is up to the processing to determine when the expression should be evaluated.

The language of the expression is inferred from the mediatype. If multiple translations are provided in the expression, the evaluator is free to choose whichever language is preferred; all translations SHALL specify the same outcome.

The language defines the forms that the expression property can take, how the information available in the context of the expression is made available within the features of the language, and how the language declares the new form of the value. Languages may only be used if this information has been appropriately defined for the context in which the QTY is used.

Information Processing Entities are not required to implement any languages in order to claim direct or indirect conformance to this specification, but SHOULD declare what languages are supported in their conformance statements. 
Language	Mediatype
OCL	text/plain+ocl
Factor	application/hl7-factor+xml
MathML	application/mathml+xml

Note: Factor is an HL7 specific language documented in the Abstract Data Types Specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QTY was encoded, if such a representation is the source of the QTY. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the quantity on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QTY derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. In a situation where the value is determined sometime after the text was entered, originalText is the text or phrase used as the basis for determining the value. The originalText is not a substitute for a valid value. If the actual value of the QTY is not valid, then the QTY SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: the details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The uncertainty of the quantity using a distribution function and its parameters. It is the primary measure of variance/uncertainty of the value (the square root of the sum of the squares of the differences between all data points and the mean). The actual type of uncertainty depends on the type of the QTY and is fixed for each type.

Uncertainty SHALL only be applied to value domains that have a continuous distribution (REAL, PQ, MO, and TS). Uncertainty MAY be applied to the numerator and denominator of a RTO separately.

Uncertainty SHALL not have an expression. Uncertainty SHALL not have uncertainty of its own. Uncertainty SHALL not have originalText - any uncertainty associated with the QTY should be conveyed as part of the originalText of the QTY itself.

Note: uncertainty does not have it&#39;s own originalText because it is expected that the uncertainty of the quantity should be expressed in the originalText of the quantity itself.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="uncertainRange" type="IVL_QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Indicates that the value comes from a range of possible values. 

uncertainRange is used where the actual value is unknown, but it is known that the value comes from a known range of possible values. uncertainRange differs from uncertainty in that uncertainty is used to report a particular value along with an associated distribution of uncertainty for the value, or to report the summary distribution of a set of data, whereas uncertainRange indicates that there is a single value that, although unknown, comes from a particular range of values. No inference regarding distribution of values can be taken. uncertainRange is often associated with an instruction to perform a particular operation at some point within a given time interval.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="uncertaintyType" type="UncertaintyType" use="optional">
          <xsd:annotation>
            <xsd:documentation>A code specifying the type of probability distribution in uncertainty. 

The null value (unknown) for the type code indicates that the probability distribution type is unknown. In that case, uncertainty has the meaning of an informal guess if it is populated.
If populated, the value of this attribute SHALL be taken from the HL7 DistributionType code system.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_QTY">
    <xsd:annotation>
      <xsd:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_QTY-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_QTY-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_QTY-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_QTY-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_QTY">
        <xsd:sequence>
          <xsd:element name="low" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the low limit. If the low limit is not known, a nullFlavor may be specified.
The low limit SHALL NOT be positive infinity
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the high limit. If the high limit is not known, a nullFlavor may be specified.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="any" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Specifies that some particular value lies within the interval.

This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_QTY">
    <xsd:annotation>
      <xsd:documentation>Abstract; specializes ANY

Parameter: T : QTY

An unordered set of distinct values which are quantities. 

Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).

QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).

QSETs SHALL not contain null or nullFlavored values as members of the set.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_QTY-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the &#60;i&#62;QSET&#60;/i&#62; is not valid, then the &#60;i&#62;QSET&#60;/i&#62; SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="Decimal">
    <xsd:restriction base="xsd:double" />
  </xsd:simpleType>
  <xsd:complexType name="CS">
    <xsd:annotation>
      <xsd:documentation>Coded data in its simplest form, where only the code is not predetermined. 

The code system and code system version are implied and fixed by the context in which the CS value occurs.  

Due to its highly restricted functionality, CS SHALL only be used for simple structural attributes with highly controlled and stable terminologies where:
&#60;ul&#62;
	&#60;li&#62;all codes come from a single code system&#60;/li&#62;
	&#60;li&#62;codes are not reused if their concept is deprecated&#60;/li&#62;
	&#60;li&#62;the publication and extensibility properties of the code system are well described and understood.&#60;/li&#62;
&#60;/ul&#62;</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="code is required">
          <sch:rule abstract="true" id="CS-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @code)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="code" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>The plain code symbol defined by the code system. if the code value is empty or null, then there is no code in the code system that represents the concept.
Code SHALL only contain characters that are either a letter, a digit, or one of &#39;.&#39;, &#39;-&#39;, &#39;_&#39; or &#39;:&#39;. Code systems that are used with CS SHALL NOT define code symbols or expression syntaxes that contain whitespace or any other characters not in this list.
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="AD">
    <xsd:annotation>
      <xsd:documentation>Mailing and home or office addresses. 

AD is primarily used to communicate data that will allow printing mail labels, or that will allow a person to physically visit that address. The postal address datatype is not supposed to be a container for additional information that might be useful for finding geographic locations (e.g., GPS coordinates) or for performing epidemiological studies. Such additional information should be captured by other, more appropriate data structures.

Addresses are essentially sequences of address parts, but add a &#34;use&#34; code and a valid time range for information about if and when the address can be used for a given purpose.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="AD-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on AD attributes">
          <sch:rule abstract="true" id="AD-1">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="part" type="ADXP" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A sequence of address parts, such as street or post office Box, city, postal code, country, etc.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A General Timing Specification (GTS) specifying the periods of time during which the address can be used. This is used to specify different addresses for different times of the week or year.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="use" type="set_PostalAddressUse" use="optional">
          <xsd:annotation>
            <xsd:documentation>A set of codes advising a system or user which address in a set of like addresses to select for a given purpose. 

An address without specific use code might be a default address useful for any purpose, but an address with a specific use code would be preferred for that respective purpose.

If populated, the values contained in this attribute SHALL be taken from the HL7 PostalAddressUse code system. </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="isNotOrdered" type="xsd:boolean" default="false" use="optional">
          <xsd:annotation>
            <xsd:documentation>A boolean value specifying whether the order of the address parts is known or not. While the address parts are always a sequence, the order in which they are presented may or may not be known to be true or important. Where this matters, the isNotOrdered property can be used to convey this information. The default value for isNotOrdered is false.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP">
    <xsd:annotation>
      <xsd:documentation>A part that may have a type-tag signifying its role in the address. Typical parts that exist in about every address are street, house number, or post box, postal code, city, country but other roles may be defined regionally, nationally, or on an enterprise level (e.g. in military addresses). 

Addresses are usually broken up into lines, which may be indicated by special line-breaking delimiter elements (e.g., DEL). </xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ADXP-0">
            <sch:assert test="@nullFlavor or @type = &#34;DEL&#34; or (string-length(@value) &#62; 0)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="XP">
        <xsd:attribute name="type" type="AddressPartType" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether an address part names the street, city, country, postal code, post box, etc.
If the type is NULL the address part is unclassified and would simply appear on an address label as is.
If populated, the value of this attribute SHALL be taken from the HL7 AddressPartType code system.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="XP">
    <xsd:annotation>
      <xsd:documentation>A part of a name or address. Each part is a character string that may be coded, and that also may have a nullFlavor. The string content must always be provided whether a code is provided or not.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="XP-0">
            <sch:assert test="@codeSystem or not(@code)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="XP-1">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="nullFlavor" type="NullFlavor" use="optional">
      <xsd:annotation>
        <xsd:documentation>If the part is not a proper value, indicates the reason.

For further information concerning nullFlavor, see 7.3.3.3.1</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="value" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The actual string value of the part. If no nullFlavor is provided, some content must be present in this attribute.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="code" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>A code assigned to the part by some coding system, if appropriate.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="codeSystem" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The code system from which the code is taken. 

The choice of coding system depends on the part type defined in the concrete specializations. The codeSystem SHALL be populated if a code is populated.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The version of the coding system, if required.

The codeSystem SHALL be populated if a codeSystemVersion is populated.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="language" type="Code" use="optional">
      <xsd:annotation>
        <xsd:documentation>The human language of the content. Valid codes are taken from the IETF &#38;lt;a href=&#34;http://www.ietf.org/rfc/rfc3066.txt&#34; \o &#34;http://www.ietf.org/rfc/rfc3066.txt&#34;&#38;gt;RFC 3066&#38;lt;/a&#38;gt;. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.

While parts may be assigned a language, the meaning of the part is not dependent on the language, and applications SHALL not be required to indicate the linguistic origin of any name or address part.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="EN">
    <xsd:annotation>
      <xsd:documentation>A name for a person, organization, place or thing. 

Examples:   &#34;Jim Bob Walton, Jr.&#34;, &#34;Health Level Seven, Inc.&#34;, &#34;Lake Tahoe&#34;, etc. An entity name may be as simple as a character string or may consist of several entity name parts, such as, &#34;Jim&#34;, &#34;Bob&#34;, &#34;Walton&#34;, and &#34;Jr.&#34;, &#34;Health Level Seven&#34; and &#34;Inc.&#34;.

Entity names are essentially sequences of entity name parts, but add a &#34;use&#34; code and a valid time range for information about when the name was used and how to choose between multiple aliases that may be valid at the same point in time.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="EN-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="part" type="ENXP" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A sequence of name parts, such as given name or family name, prefix, suffix, etc.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="use" type="set_EntityNameUse" use="optional">
          <xsd:annotation>
            <xsd:documentation>A set of codes advising a system or user which name in a set of names to select for a given purpose. 
A name without specific use code might be a default name useful for any purpose, but a name with a specific use code would be preferred for that respective purpose. Names SHOULD not be collected without at least one use code, but names MAY exist without  use code, particularly for legacy data.

If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNameUse2 code system</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ENXP">
    <xsd:annotation>
      <xsd:documentation>A part that may have a type code signifying the role of the part in the whole entity name, and qualifier codes for more detail about the name part type. (Typical name parts for person names are given names, and family names, titles, etc. ). </xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ENXP-0">
            <sch:assert test="@nullFlavor or (string-length(@value) &#62; 0)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="XP">
        <xsd:attribute name="type" type="EntityNamePartType" use="optional">
          <xsd:annotation>
            <xsd:documentation>Indicates whether the name part is a given name, family name, prefix, suffix, etc. 

Not every name part must have a type code, if the type code is unknown, not applicable, or simply undefined this is expressed by a null value (type.isNull). For example, a name may be &#34;Rogan Sulma&#34; and it may not be clear which one is a given name or which is a last name, or whether Rogan may be a title.
If populated, the value of this attribute SHALL be taken from the HL7 EntityNamePartType2 code system. </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="qualifier" type="set_EntityNamePartQualifier" use="optional">
          <xsd:annotation>
            <xsd:documentation>The qualifier is a set of codes each of which specifies a certain subcategory of the name part in addition to the main name part type.
Example, a given name may be flagged as a nickname (CL), a family name may be a name acquired by marriage (SP) or a name from birth (BR).
If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNamePartQualifier2 code system. </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS">
    <xsd:annotation>
      <xsd:documentation>A quantity specifying a point on the axis of natural time. A point in time is most often represented as a calendar expression.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value xor uncertainRange">
          <sch:rule abstract="true" id="TS-0">
            <sch:assert test="not(@value and uncertainRange)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="TS-1">
            <sch:assert test="@nullFlavor or @value or uncertainRange" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" use="optional">
          <xsd:annotation>
            <xsd:documentation>The value of the TS. value is a string with the format &#34;YYYY[MM[DD[HH[MM[SS[.U[U[U[U]]]]]]]]][+|-ZZzz]&#34; that conforms to the constrained ISO 8601 defined in ISO 8824 (ASN.1) under clause 32 (generalized time). The format should be used to the degree of precision that is appropriate</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RTO">
    <xsd:annotation>
      <xsd:documentation>A quantity constructed as the quotient of a numerator quantity divided by a denominator quantity. 
Common factors in the numerator and denominator are not automatically cancelled out. 
The RTO datatype supports titers (e.g., &#34;1:128&#34;) and other quantities produced by laboratories that truly represent ratios. Ratios are not simply &#34;structured numerics&#34;, particularly blood pressure measurements (e.g. &#34;120/60&#34;) are not ratios.
Notes: 
1.	Ratios are different from rational numbers, i.e., in ratios common factors in the numerator and denominator never cancel out. A ratio of two real or integer numbers is not automatically reduced to a real number. This datatype is not defined to generally represent rational numbers. It is used only if common factors in numerator and denominator are not supposed to cancel out. This is only rarely the case. For observation values, ratios occur almost exclusively with titers. In most other cases, REAL should be used instead of the RTO.
2.	Since many implementation technologies expect generics to be collections, or only have one parameter, RTO is not implemented as a generic in this specification. Constraints at the point where the RTO is used will define which form of QTY are used.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="numerator and denominator required">
          <sch:rule abstract="true" id="RTO-0">
            <sch:assert test="@nullFlavor or ((numerator and not(numerator/@nullFlavor)) and (numerator and not(numerator/@nullFlavor)))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on RTO Attributes">
          <sch:rule abstract="true" id="RTO-1">
            <sch:assert test="count(*[self::numerator or self::denominator][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="RTO-2">
            <sch:assert test="not(uncertainty)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no TS">
          <sch:rule abstract="true" id="RTO-3">
            <sch:assert test="not(numerator/@xsi:type = &#34;TS&#34;) and not(denominator/@xsi:type = &#34;TS&#34;)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="numerator" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The quantity that is being divided in the ratio</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="denominator" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The quantity that divides the numerator in the ratio. 
The denominator SHALL not be zero.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MO">
    <xsd:annotation>
      <xsd:documentation>A MO is a quantity expressing the amount of money in some currency. 
Currencies are the units in which monetary amounts are denominated in different economic regions. While the monetary amount is a single kind of quantity (money) the exchange rates between the different units are variable. This is the principle difference between PQ and MO, and the reason why currency units are not physical units.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null or currency">
          <sch:rule abstract="true" id="MO-0">
            <sch:assert test="(@nullFlavor or @currency) and not(@nullFlavor and @currency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="MO-1">
            <sch:assert test="@nullFlavor or @value or uncertainRange" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value xor uncertainRange">
          <sch:rule abstract="true" id="MO-2">
            <sch:assert test="not(@value and uncertainRange)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The value of the MO if non Null. MO values are usually precise to 0.01 (one cent, penny, paisa, etc.), or 1 (yen, forint, etc)</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="currency" type="Code" use="optional">
          <xsd:annotation>
            <xsd:documentation>The currency unit as defined in ISO 4217</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQ">
    <xsd:annotation>
      <xsd:documentation>A dimensioned quantity expressing the result of measuring</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="PQ-0">
            <sch:assert test="@nullFlavor or @value or uncertainRange" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value xor uncertainRange">
          <sch:rule abstract="true" id="PQ-1">
            <sch:assert test="not(@value and uncertainRange)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="translation" type="PQR" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>An alternative representation of the same physical quantity expressed in a different unit from a different unit code system and possibly with a different value.

It is not necessary for information processing entities to check and enforce that the translations are valid translations of the base unit, but they are allowed to do so, and to reject instances where the translations are not valid.

Note Translations are allowed to contain other representations in UCUM units, but there is generally no point to this as it&#39;s possible to convert from UCUM form to another.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="value" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>the number which is multiplied by the unit to make the PQ or PQR value if not nullFlavored</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="unit" type="Code" use="optional">
          <xsd:annotation>
            <xsd:documentation>The unit of measure specified in the Unified Code for Units of Measure (UCUM). 

UCUM defines two forms of expression, case sensitive and case insensitive. &#60;i&#62;PQ&#60;/i&#62; uses the case sensitive codes. The codeSystem OID for the case sensitive form is 2.16.840.1.113883.6.8. The default value for unit is the UCUM code &#34;1&#34; (unity).

Equality of physical quantities does not require the values and units to be equal independently. Value and unit is only how we represent physical quantities. For example, 1 m equals 100 cm. Although the units are different and the values are different, the physical quantities are equal. Therefore one should never expect a particular unit for a physical quantity but instead allow for automated conversion between different comparable units. 

The unit SHALL come from UCUM, which only specifies unambiguous measurement units. Sometimes it is not clear how some measurements in healthcare map to UCUM codes.

Note: The general pattern for a measurement is  &#60;i&#62;value&#60;/i&#62; &#60;u&#62;unit&#60;/u&#62;  of &#60;b&#62;Thing&#60;/b&#62;. In this scheme, the PQ represents the  &#60;i&#62;value&#60;/i&#62; and the &#60;u&#62;unit&#60;/u&#62;, and the &#60;b&#62;Thing&#60;/b&#62; is described by some coded concept that is linked to the PQ by the context of use. This maps obviously to some measurements, such as &#60;b&#62;Patient Body Temperature&#60;/b&#62; of &#60;i&#62;37&#60;/i&#62; &#60;u&#62;Celsius&#60;/u&#62;, and &#60;i&#62;250&#60;/i&#62; &#60;u&#62;mg/day&#60;/u&#62; of &#60;b&#62;Salicylate&#60;/b&#62;.

However for some measurements that arise in healthcare, the scheme is not so obvious. Two classic examples are 5 Drinks of Beer, and 3 Acetominophen tablets. At first glance it is tempting to classify these measurments like this: &#60;i&#62;5&#60;/i&#62; &#60;u&#62;drinks&#60;/u&#62; of &#60;b&#62;Beer&#60;/b&#62; and &#60;i&#62;3&#60;/i&#62; &#60;b&#62;Acetominophen&#60;/b&#62; &#60;u&#62;tablets&#60;/u&#62;. The problem with this is that UCUM does not support units of &#34;beer&#34;, &#34;tablets&#34; or &#34;scoops&#34;.

The reason for this is that neither tablets or scoops are proper units. What kind of tablets? How big is the glass? In these kinds of cases, the concept that appears to be a unit needs to further specified before interoperability is established. If a correct amount is required, then it is generally appropriate to specify an exact measurement with an appropriate UCUM unit. If this is not possible, then the concept is not part of the measurement. UCUM provides a unit called unity for use in these cases. The proper way to understand these measurements as &#60;i&#62;3&#60;/i&#62; &#60;u&#62;1&#60;/u&#62; &#60;b&#62;Acetominophen&#60;/b&#62; tablets, where 1 is the UCUM unit for unity, and the &#60;b&#62;Thing&#60;/b&#62; has a qualifier. The context of use will need to provide the extra qualifying information.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="codingRationale" type="CodingRationale" use="optional">
          <xsd:annotation>
            <xsd:documentation>The reason that this PQ or PQR was provided. More than one reason may be given. For possible values, see 7.5.1.4.10 CD.codingRationale.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQR">
    <xsd:annotation>
      <xsd:documentation>Specializes CD.CV
An extension of the coded value datatype representing a physical quantity using a unit from any code system. Used to show alternative representation for a physical quantity. The coded value represents the unit (usually in some other coding system than UCUM).</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="PQR-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="PQR-1">
            <sch:assert test="not(@originalText)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PQR">
          <sch:rule abstract="true" id="PQR-2">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not(@controlInformationRoot) and not(@controlInformationExtension) and not(@updateMode)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="PQR-3">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no source">
          <sch:rule abstract="true" id="PQR-4">
            <sch:assert test="not(source)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="CD">
        <xsd:attribute name="value" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The magnitude of the measurement value in terms of the unit specified by this code.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="REAL">
    <xsd:annotation>
      <xsd:documentation>Fractional numbers. Typically used whenever quantities are measured, estimated, or computed from other real numbers. The typical representation is decimal, where the number of significant decimal digits is known as the precision.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value xor uncertainRange">
          <sch:rule abstract="true" id="REAL-0">
            <sch:assert test="not(@value and uncertainRange)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="REAL-1">
            <sch:assert test="@nullFlavor or @value or uncertainRange" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The value of the REAL. 

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT">
    <xsd:annotation>
      <xsd:documentation>Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers that are results of counting and enumerating. Integer numbers are discrete, the set of integers is infinite but countable. No arbitrary limit is imposed on the range of integer numbers.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="INT-0">
            <sch:assert test="not(uncertainty)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value xor uncertainRange">
          <sch:rule abstract="true" id="INT-1">
            <sch:assert test="not(@value and uncertainRange)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="INT-2">
            <sch:assert test="@nullFlavor or @value or uncertainRange" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation>The value of the INT. Note that this specification imposes no limitations on the size of integer, but most implementations will map this to a 32 or 64 bit integer.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as an intersection of other sets.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of other QSETs that are involved in the intersection</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="SD.TEXT">
    <xsd:annotation>
      <xsd:documentation>A definition of structured text that can be used in healthcare. 

The structured text is based on an XHTML-like arrangement that ensures the text is properly marked up with semantics, and provides a common base line for implementation in healthcare.

The type SD.TEXT is also known as StrucDoc.Text (for legacy reasons). </xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="rules">
          <sch:rule abstract="true" id="SD.TEXT-0">
            <sch:assert test="not(@flavorId) and not(@updateMode)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value if not nullFlavored">
          <sch:rule abstract="true" id="SD.TEXT-1">
            <sch:assert test="(@nullFlavor) or (footnote or footnoteRef or linkHtml or sub or sup or content or br or renderMultiMedia or paragraph or list or table or text())" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.Footnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml">
              <xsd:annotation>
                <xsd:documentation>A HTML-type link</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sub" type="StrucDoc.Sub">
              <xsd:annotation>
                <xsd:documentation>Subscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sup" type="StrucDoc.Sup">
              <xsd:annotation>
                <xsd:documentation>Superscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="content" type="StrucDoc.Content">
              <xsd:annotation>
                <xsd:documentation>Nested Content</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="br" type="StrucDoc.Br">
              <xsd:annotation>
                <xsd:documentation>A hard line break</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia">
              <xsd:annotation>
                <xsd:documentation>Multimedia</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="paragraph" type="StrucDoc.Paragraph">
              <xsd:annotation>
                <xsd:documentation>A paragraph of text and other CMContent content.</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="list" type="StrucDoc.List">
              <xsd:annotation>
                <xsd:documentation>List based content.</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="table" type="StrucDoc.Table">
              <xsd:annotation>
                <xsd:documentation>Table</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
          </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="ID" type="xsd:ID" use="optional" />
        <xsd:attribute name="language" type="Code" use="optional" />
        <xsd:attribute name="styleCode" type="set_Code" use="optional" />
        <xsd:attribute name="mediaType" type="xsd:string" default="text/x-hl7-text+xml" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="XmlID">
    <xsd:restriction base="xsd:ID" />
  </xsd:simpleType>
  <xsd:simpleType name="set_Code">
    <xsd:list itemType="Code" />
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Footnote">
    <xsd:annotation>
      <xsd:documentation>Indicates a footnote. The content contained within the Footnote is the content of the footnote. When the document is rendered, a link to the footnote is displayed inline with the flow of text adjacent to the footnote.
Note: Receivers are required to interpret these elements when rendering by visually distinguishing footnoted text. The exact rendition is at the discretion of the recipient, and might include a mark at the location of the footnote with a hyperlink to the footnoted text, a simple demarcation (such as &#34;This is the text [this is the footnote] that is being footnoted&#34;), etc</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="Some content required">
          <sch:rule abstract="true" id="StrucDoc.Footnote-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=&#39;&#39;])!=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml">
          <xsd:annotation>
            <xsd:documentation>A HTML-type link</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="sub" type="StrucDoc.Sub">
          <xsd:annotation>
            <xsd:documentation>Subscript text</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="sup" type="StrucDoc.Sup">
          <xsd:annotation>
            <xsd:documentation>Superscript text</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="content" type="StrucDoc.Content">
          <xsd:annotation>
            <xsd:documentation>Nested Content</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="br" type="StrucDoc.Br">
          <xsd:annotation>
            <xsd:documentation>A hard line break</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia">
          <xsd:annotation>
            <xsd:documentation>Multimedia</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="paragraph" type="StrucDoc.Paragraph">
          <xsd:annotation>
            <xsd:documentation>A paragraph of text and other CMContent content.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="list" type="StrucDoc.List">
          <xsd:annotation>
            <xsd:documentation>List based content.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="table" type="StrucDoc.Table">
          <xsd:annotation>
            <xsd:documentation>Table</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:attributeGroup name="StrucDoc.Base">
    <xsd:annotation>
      <xsd:documentation>Defines basic identification and styling attributes shared by many structured document elements</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="ID" type="xsd:ID" use="optional" />
    <xsd:attribute name="language" type="Code" use="optional" />
    <xsd:attribute name="styleCode" type="set_Code" use="optional" />
  </xsd:attributeGroup>
  <xsd:complexType name="StrucDoc.FootnoteRef">
    <xsd:annotation>
      <xsd:documentation>A reference to an existing footnote within the document context. This may be used when the same footnote is being used multiple times. The value of the footnoteRef.IDREF must be an footnote.ID value in the same document</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have a reference">
          <sch:rule abstract="true" id="StrucDoc.FootnoteRef-0">
            <sch:assert test="@IDREF" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="IDREF" type="xsd:IDREF" use="optional">
      <xsd:annotation>
        <xsd:documentation>The identity of the referenced footnote.
Refer to section A.2 for the meaning of the XMLIDREF stereotype
</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:simpleType name="XmlIDREF">
    <xsd:restriction base="xsd:IDREF" />
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.LinkHtml">
    <xsd:annotation>
      <xsd:documentation>A hypertext reference to another document. These links are generally shown as hyperlinks that a user may activate when viewing the document.

The link functionality provides a generic referencing mechanism, similar, but not identical, to the HTML anchor tag. It can be used to reference identifiers that are either internal or external to the document or the document context.

Multimedia that is integral to a document must be referenced by the renderMultiMedia element (see below). Multimedia that is simply referenced by the document and not an integral part of the document can by provided by a link. There is no requirement that a receiver render an internal or external link, or the target of an external link</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="StrucDoc.LinkHtml-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=&#39;&#39;])!=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="optional" />
    <xsd:attribute name="href" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The URL that identifiers the target documen/object of the link. The target is an XML identifier either internal or external to the document.The context of use must clearly define the scope of resolution of the link. Following the conventions of HTML, an internal link  usually a link within the scope of the context of the document - is prefaced with the pound sign.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="rel" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>This attribute describes the relationship from the current document to the anchor specified by the href attribute. The value of this attribute is a space-separated list of link types. 
If populated, the value of this attribute SHALL be taken from one of these values listed in LinkType, taken from the HTML specification
</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="rev" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>This attribute is used to describe a reverse link [p.155] from the anchor specified by the href attribute to the current document. The value of this attribute is a space-separated list of link types.See above for valid values</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="title" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>This attribute offers advisory information about the element for which it is set. The title attribute has an additional role when used with a LINK element that designates an external style sheet. Please consult the HTML standard for additional information.
Note: Values of the title attribute may be rendered by user agents in a variety of ways. For instance, visual browsers frequently display the title as a &#34;tool tip&#34; (a short message that appears when the pointing device pauses over an object). Audio user agents may speak the title information in a similar context. For example, setting the attribute on a link allows user agents (visual and non-visual) to tell users about the nature of the linked resource
</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sub">
    <xsd:annotation>
      <xsd:documentation>Indicates that the value text should be rendered as subscript when presented. i.e. H2O</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sub-0">
            <sch:assert test="string-length(text()) != 0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sup">
    <xsd:annotation>
      <xsd:documentation>Indicates that the value text should be rendered as superscript when presented. i.e. x2.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sup-0">
            <sch:assert test="string-length(text()) != 0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Content">
    <xsd:annotation>
      <xsd:documentation>Used to wrap a string of text so that it can be explicitly referenced, or so that it can suggest rendering characteristics. Content can be nested recursively, which enables wrapping a string of plain text down to as small a chunk as desired. 
Content has an optional identifier that can serve as the target of a reference. This identifier, represented as an XML ID attribute, must be unique within the document context. The originalText attribute of a datatype defined in this specification may make explicit reference to the content using the identifier, thereby indicating the original text associated with the datatype. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml">
          <xsd:annotation>
            <xsd:documentation>A HTML-type link</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="sub" type="StrucDoc.Sub">
          <xsd:annotation>
            <xsd:documentation>Subscript text</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="sup" type="StrucDoc.Sup">
          <xsd:annotation>
            <xsd:documentation>Superscript text</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="content" type="StrucDoc.Content">
          <xsd:annotation>
            <xsd:documentation>Nested Content</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="br" type="StrucDoc.Br">
          <xsd:annotation>
            <xsd:documentation>A hard line break</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia">
          <xsd:annotation>
            <xsd:documentation>Multimedia</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="revised" type="StrucDoc.Revised" use="optional">
      <xsd:annotation>
        <xsd:documentation>can be used to indicate narrative changes from the last version of a CDA document. The attribute is limited to a single generation, in that it only reflects the changes from the preceding version of a document. Receivers SHALL interpret the &#34;revised&#34; attribute when rendering by visually distinguishing or suppressing deleted narrative.
Note:  If applied, this attribute SHALL be used in conjunction with appropriate document version tracking as defined in the applicable conformance statement for the document context
</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.Br">
    <xsd:annotation>
      <xsd:documentation>A hard line break, like in XHTML.</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.RenderMultiMedia">
    <xsd:annotation>
      <xsd:documentation>References multimedia content that is integral to the document, and serves to show where the referenced multimedia is to be rendered. The multi media content must be contained within the context of the document. 
There is an optional caption, and contains a required referencedObject attribute (of type XML IDREFS), the values of which must equal the XML ID value(s) of ObservationMedia or RegionOfInterest CDA entries within the document context. </xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one reference">
          <sch:rule abstract="true" id="StrucDoc.RenderMultiMedia-0">
            <sch:assert test="@referencedObject" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="caption" type="StrucDoc.Caption" minOccurs="0" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation>An optional caption for the multimedia content</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="referencedObject" type="set_IDREF" use="optional">
      <xsd:annotation>
        <xsd:documentation>The references are to other identified objects within the document context.
Refer to section A.2 for the meaning of the XMLIDREF stereotype.
</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Caption">
    <xsd:annotation>
      <xsd:documentation>A label for a paragraph, list, list item, table, or table cell. It may also be used within RenderMultiMedia to indicate a label for referenced ObservationMedia and RegionOfInterest entries. A Caption contains plain text and may contain links and footnotes.

If a caption is defined, it SHALL be rendered, and SHALL be presented before any the element with which it is associated.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml">
          <xsd:annotation>
            <xsd:documentation>A HTML-type link</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="sub" type="StrucDoc.Sub">
          <xsd:annotation>
            <xsd:documentation>Subscript text</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="sup" type="StrucDoc.Sup">
          <xsd:annotation>
            <xsd:documentation>Superscript text</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:simpleType name="set_IDREF">
    <xsd:list itemType="xsd:IDREF" />
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Paragraph">
    <xsd:annotation>
      <xsd:documentation>Similar to the HTML paragraph, which allows blocks of narrative to be broken up into logically consistent structures</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.Footnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml">
              <xsd:annotation>
                <xsd:documentation>A HTML-type link</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sub" type="StrucDoc.Sub">
              <xsd:annotation>
                <xsd:documentation>Subscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sup" type="StrucDoc.Sup">
              <xsd:annotation>
                <xsd:documentation>Superscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="content" type="StrucDoc.Content">
              <xsd:annotation>
                <xsd:documentation>Nested Content</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="br" type="StrucDoc.Br">
              <xsd:annotation>
                <xsd:documentation>A hard line break</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia">
              <xsd:annotation>
                <xsd:documentation>Multimedia</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Captioned">
    <xsd:annotation>
      <xsd:documentation>An abstract ancestor for all types that have captions.

If a caption is defined, it SHALL be rendered, and SHALL be presented before any the element with which it is associated</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="caption" type="StrucDoc.Caption" minOccurs="0" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation>The contents of the Content.
Note: Refer to section A.2 for the meaning of the Anonymous stereotype
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.List">
    <xsd:annotation>
      <xsd:documentation>Similar to an HTML list. There is an optional caption, and one or more items. The list must be ordered or not ordered; this must always be known, </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element name="item" type="StrucDoc.Item" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="listType" type="StrucDoc.ListType" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether the list is ordered or unordered. 
If populated, the value of this attribute SHALL be taken from one of these values: 
StrucDoc.ListType Enumeration
1	ordered	ordered	The list is ordered
1	unordered	unordered	The list is not ordered

The default value is unordered.

Note: Unordered lists are typically rendered with bullets, whereas ordered lists are typically rendered with numbers, although this is not a requirement.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Item">
    <xsd:annotation>
      <xsd:documentation>An item in a list. </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.Footnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml">
              <xsd:annotation>
                <xsd:documentation>A HTML-type link</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sub" type="StrucDoc.Sub">
              <xsd:annotation>
                <xsd:documentation>Subscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sup" type="StrucDoc.Sup">
              <xsd:annotation>
                <xsd:documentation>Superscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="content" type="StrucDoc.Content">
              <xsd:annotation>
                <xsd:documentation>Nested Content</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="br" type="StrucDoc.Br">
              <xsd:annotation>
                <xsd:documentation>A hard line break</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia">
              <xsd:annotation>
                <xsd:documentation>Multimedia</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="paragraph" type="StrucDoc.Paragraph">
              <xsd:annotation>
                <xsd:documentation>A paragraph of text and other CMContent content.</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="list" type="StrucDoc.List">
              <xsd:annotation>
                <xsd:documentation>List based content.</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="table" type="StrucDoc.Table">
              <xsd:annotation>
                <xsd:documentation>Table</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Table">
    <xsd:annotation>
      <xsd:documentation>A table. May have a caption, and SHALL have at least one row. A table may have optional header and footer rows. All rows are defined in groups. A table may also have col and colgroup elements to define styles for columns.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="columns">
          <sch:rule abstract="true" id="StrucDoc.Table-0">
            <sch:assert test="not(col) or not(column)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element name="col" type="StrucDoc.Col" minOccurs="0" maxOccurs="unbounded" />
          <xsd:element name="colgroup" type="StrucDoc.ColGroup" minOccurs="0" maxOccurs="unbounded" />
          <xsd:element name="thead" type="StrucDoc.TRowGroup" minOccurs="0" maxOccurs="1" />
          <xsd:element name="tfoot" type="StrucDoc.TRowGroup" minOccurs="0" maxOccurs="1" />
          <xsd:element name="tbody" type="StrucDoc.TRowGroup" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="summary" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute provides a summary of the tables purpose and structure for user agents rendering to non-visual media such as speech and Braille. This is different from the caption in that it must be plain text, and it is usually longer</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute specifies the desired width of the entire table and is intended for visual user agents. 

The rules described in the html specification for table width calculations apply to the tables described here.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="border" type="StrucDoc.Length" use="optional">
          <xsd:annotation>
            <xsd:documentation>The width of the border</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="frame" type="StrucDoc.Frame" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute specifies which sides of the frame  surrounding a table will be visible (i.e. which borders are visible).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="rules" type="StrucDoc.Rules" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute specifies which rules (i.e. borders) will appear between cells within a table. The rendering of rules is user agent dependent</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="cellspacing" type="StrucDoc.Length" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute specifies how much space the user agent should leave between the left side of the table and the left-hand side of the leftmost column, the top of the table and the top side of the topmost row, and so on for the right and bottom of the table. The attribute also specifies the amount of space to leave between cells.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="cellpadding" type="StrucDoc.Length" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute specifies the amount of space between the border of the cell and its contents. If the value of this attribute is a pixel length, all four margins should be this distance from the contents. If the value of the attribute is a percentage length, the top and bottom margins should be equally separated from the content based on a percentage of the available vertical space, and the left and right margins should be equally separated from the content based on a percentage of the available horizontal space.
Note: consult the HTML specification for further information
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.Col">
    <xsd:annotation>
      <xsd:documentation>Applies a consistent style to every cell in a column.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.ColItem">
    <xsd:annotation>
      <xsd:documentation>Abstract ancestor for common properties of col and colgroup.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:attribute name="span" type="xsd:int" default="1" use="optional">
          <xsd:annotation>
            <xsd:documentation>The number of columns this column definition spans.. Default value is 1.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional">
          <xsd:annotation>
            <xsd:documentation>The length for the column</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TableItem">
    <xsd:annotation>
      <xsd:documentation>An abstract container for table items that may specify table layout details such as alignment. 

Any attributes applied to the table item also apply to any other nested table items unless specifically overridden.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="align" type="StrucDoc.Align" use="optional">
      <xsd:annotation>
        <xsd:documentation>The text alignment that applies within the cell

The default value is left.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="char" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>The character on which to align cells if align is set to char. The default value for the CHAR attribute is the decimal point of the current language--a period in English.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="charoff" type="StrucDoc.Length" use="optional">
      <xsd:annotation>
        <xsd:documentation>When present, this attribute specifies the offset to the first occurrence of the alignment character on each line. If a line doesnt include the alignment character, it should be horizontally shifted to end at the alignment position. Information Processing Entities SHALL not be required to support this attribute</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="valign" type="StrucDoc.VAlign" use="optional">
      <xsd:annotation>
        <xsd:documentation>The vertical alignment that applies within the cell

The default value is top.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.Length">
    <xsd:restriction base="xsd:string" />
  </xsd:simpleType>
  <xsd:complexType name="StrucDoc.ColGroup">
    <xsd:annotation>
      <xsd:documentation>Applies a consistent style to every cell in a group of columns.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem">
        <xsd:sequence>
          <xsd:element name="col" type="StrucDoc.Col" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRowGroup">
    <xsd:annotation>
      <xsd:documentation>A grop of rows ? may be used to associate consistent styling across a group of rows.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:element name="tr" type="StrucDoc.TRow" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The rows in the group</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRow">
    <xsd:annotation>
      <xsd:documentation>A Row in a table</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="cells">
          <sch:rule abstract="true" id="StrucDoc.TRow-0">
            <sch:assert test="th|td" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="th" type="StrucDoc.TCell" />
            <xsd:element name="td" type="StrucDoc.TCell" />
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TCell">
    <xsd:annotation>
      <xsd:documentation>A cell in a table ? may be either a normal cell or a header cell</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="no nested tables">
          <sch:rule abstract="true" id="StrucDoc.TCell-0">
            <sch:assert test="not(@table)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.Footnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml">
              <xsd:annotation>
                <xsd:documentation>A HTML-type link</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sub" type="StrucDoc.Sub">
              <xsd:annotation>
                <xsd:documentation>Subscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="sup" type="StrucDoc.Sup">
              <xsd:annotation>
                <xsd:documentation>Superscript text</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="content" type="StrucDoc.Content">
              <xsd:annotation>
                <xsd:documentation>Nested Content</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="br" type="StrucDoc.Br">
              <xsd:annotation>
                <xsd:documentation>A hard line break</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia">
              <xsd:annotation>
                <xsd:documentation>Multimedia</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="paragraph" type="StrucDoc.Paragraph">
              <xsd:annotation>
                <xsd:documentation>A paragraph of text and other CMContent content.</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="list" type="StrucDoc.List">
              <xsd:annotation>
                <xsd:documentation>List based content.</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
            <xsd:element name="table" type="StrucDoc.Table">
              <xsd:annotation>
                <xsd:documentation>Table</xsd:documentation>
              </xsd:annotation>
            </xsd:element>
          </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="abbr" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute should be used to provide an abbreviated form of the cells content, and may be rendered by user agents when appropriate in place of the cells content. Abbreviated names should be short since user agents may render them repeatedly</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="axis" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute may be used to place a cell into conceptual categories that can be considered to form axes in an n-dimensional space. User agents may give users access to these categories (e.g., the user may query the user agent for all cells that belong to certain categories, the user agent may present a table in the form of a table of contents, etc.). Please consult the HTML specification for more information. The value of this attribute is a comma-separated list of category names</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="headers" type="set_IDREF" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute specifies the list of header cells that provide header information for the current data cell. The value of this attribute is a space-separated list of ID references to header cells; those cells must be named by setting their id attribute. Authors generally use the headers attribute to help non-visual user agents render header information about data cells (e.g., header information is spoken prior to the cell data), but the attribute may also be used in conjunction with style sheets. See also the scope attribute.
Refer to section A.2 for the meaning of the XMLIDREF stereotype
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="scope" type="StrucDoc.CellScope" use="optional">
          <xsd:annotation>
            <xsd:documentation>This attribute specifies the set of data cells for which the current header cell provides header information. This attribute may be used in place of the headers attribute, particularly for simple tables.
This attribute SHALL only be populated for header cells.

The default value is Col
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="rowspan" type="xsd:int" default="1" use="optional">
          <xsd:annotation>
            <xsd:documentation>The number of rows that this cell spans. Default value is 1</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="colspan" type="xsd:int" default="1" use="optional">
          <xsd:annotation>
            <xsd:documentation>The number of columns that this cell spans. Default value is 1</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="SD.TITLE">
    <xsd:annotation>
      <xsd:documentation>A definition of structured title that can be used in healthcare. 

The structured text is based on the Structured Text definition, but only a narrow set of features can be used, consistent with a title rather than a general document.

The type SD.TITLE is also known as StrucDoc.Title (for legacy reasons). </xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="rules">
          <sch:rule abstract="true" id="SD.TITLE-0">
            <sch:assert test="not(@flavorId) and not(@updateMode)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value if not nullFlavored">
          <sch:rule abstract="true" id="SD.TITLE-1">
            <sch:assert test="(@nullFlavor) or (footnote or footnoteRef or linkHtml or sub or sup or content or br or text())" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.TitleFootnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="br" type="StrucDoc.Br" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
            <xsd:element name="sub" type="StrucDoc.Sub" />
            <xsd:element name="sup" type="StrucDoc.Sup" />
            <xsd:element name="content" type="StrucDoc.CMTitle" />
          </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="ID" type="xsd:ID" use="optional" />
        <xsd:attribute name="language" type="Code" use="optional" />
        <xsd:attribute name="styleCode" type="set_Code" use="optional" />
        <xsd:attribute name="mediaType" type="xsd:string" default="text/x-hl7-text+xml" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TitleFootnote">
    <xsd:annotation>
      <xsd:documentation>Same functionality as a normal footnote, but the content model in the parts is restricted to the kind of content that can appear in a title</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.TitleFootnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="br" type="StrucDoc.Br" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
        <xsd:element name="sub" type="StrucDoc.Sub" />
        <xsd:element name="sup" type="StrucDoc.Sup" />
        <xsd:element name="content" type="StrucDoc.CMTitle" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.CMTitle">
    <xsd:sequence>
      <xsd:element name="footnote" type="StrucDoc.TitleFootnote" minOccurs="0" maxOccurs="1" />
      <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" minOccurs="0" maxOccurs="1" />
      <xsd:element name="br" type="StrucDoc.Br" minOccurs="0" maxOccurs="1" />
      <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sub" type="StrucDoc.Sub" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sup" type="StrucDoc.Sup" minOccurs="0" maxOccurs="1" />
      <xsd:element name="content" type="StrucDoc.CMTitle" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="DSET_BL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_BL">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ST">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ST">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_SC">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_SC">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_II">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element name="item" type="II" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_II">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CD">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CD">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CO">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CS">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CS">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_AD">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_AD">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_RTO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_RTO">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_MO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_MO">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_PQ">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_REAL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_REAL">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains distinct and discrete values in no particular order.

Valid (non-nullFlavored) Discrete Sets SHALL not contain duplicate  items. The context of use SHALL define how elements are compared when checking set element uniqueness. By default, the uniqueness definition is based on the equality rules defined in this specification: Discrete sets SHALL not contain different values that are equal, and they SHALL not contain items that are null or have a nullFlavor, where the equality cannot be evaluated. When a Discrete Set is actually used, the context of use may specify an alternative definition for how uniqueness is evaluated. This alternative definition may allow for nullFlavored values in a proper set. Information Processing Entities providing alternative definitions for the uniqueness of a set SHALL make it clear in the conformance statement how such definitions are provided so that there is no ambiguity.

While proper (non-nullFlavored) sets will not contain values that do not meet the definition of uniqueness, Discrete Sets with a nullFlavor may contain elements duplicate values or values that have a nullFlavor. Note that Discrete Sets that are labelled as mandatory cannot have a nullFlavor and therefore cannot contain such values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Set

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.

The items are held in a bag because the context of use specifies exactly how uniqueness is specified for the DSET. The OCL kernel Set applies a fixed definition of equality - the equality specified for the type - which may be less granular that the context of use. Though the internal structure allows duplicates, all the items in the set SHALL be unique according the definition provided by the context of use. If the context of use does not make this clear, the default behaviour is the equality definitions provided in this standard. 

Note: There is no support for the formal definition of the uniqueness constraints because of the cost of providing such a framework, and the lack of apparent use for one.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT">
    <xsd:annotation>
      <xsd:documentation>Abstract. Specializes ANY. 

Parameter: T : ANY

A collection of values which can be enumerated using an iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_BL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ST">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_SC">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_II">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element name="item" type="II" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CD">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CS">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_AD">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_RTO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_MO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_REAL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

An unordered collection of values, where each value can be contained more than once in the collection.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Bag.

This is an example of the primitive type wrapping pattern. See section 6.3 for more details.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_BL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ST">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_SC">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_II">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element name="item" type="II" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CD">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CS">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_AD">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_RTO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_MO">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_REAL">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT">
    <xsd:annotation>
      <xsd:documentation>Specializes COLL

Parameter: T : ANY

A collection that contains discrete (but not necessarily distinct) values in a defined sequence. Values are also assigned an offset; the first value has the offset of zero.

The sequence is an ordered collection of values, but no particular order is inherently associated with the sequence. The meaning of the order of the items SHOULD be defined where a LIST is used. Note that in some cases, the order is fixed ( e.g. HIST), but in other cases, the order is not fixed: only the meaning associated with the order in the instance is defined (e.g. EN, AD).</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The contents of the Sequence

This is an example of the primitive type wrapping pattern. See section 6.3 for more details</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS">
    <xsd:annotation>
      <xsd:documentation>A sequence of sampled values scaled and translated from a list of integer values. Used to specify sampled biosignals.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The origin of the list item value scale. The physical quantity that a zero-digit in the sequence would represent</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A ratio-scale quantity that is factored out of the digit sequence. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A sequence of raw digits for the sample values. This is typically the raw output of an A/D converter.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_PQ">
    <xsd:annotation>
      <xsd:documentation>A sequence of sampled values scaled and translated from a list of integer values. Used to specify sampled biosignals.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_PQ-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_PQ-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The origin of the list item value scale. The physical quantity that a zero-digit in the sequence would represent</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A ratio-scale quantity that is factored out of the digit sequence. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A sequence of raw digits for the sample values. This is typically the raw output of an A/D converter.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_REAL">
    <xsd:annotation>
      <xsd:documentation>A sequence of sampled values scaled and translated from a list of integer values. Used to specify sampled biosignals.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_REAL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_REAL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="REAL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The origin of the list item value scale. The physical quantity that a zero-digit in the sequence would represent</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A ratio-scale quantity that is factored out of the digit sequence. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A sequence of raw digits for the sample values. This is typically the raw output of an A/D converter.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT">
    <xsd:annotation>
      <xsd:documentation>A sequence of sampled values scaled and translated from a list of integer values. Used to specify sampled biosignals.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="INT" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The origin of the list item value scale. The physical quantity that a zero-digit in the sequence would represent</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A ratio-scale quantity that is factored out of the digit sequence. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A sequence of raw digits for the sample values. This is typically the raw output of an A/D converter.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS">
    <xsd:annotation>
      <xsd:documentation>A periodic or monotone sequence of values generated from a few parameters, rather than being enumerated. Used to specify regular sampling points for biosignals.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS-2">
            <sch:assert test="not(period) or (period/@nullFlavor) or (period/@value &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The first item in this sequence. This is the start-value of the generated list.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between one value and its previous different value. 

For example: To generate the sequence (1; 4; 7; 10; 13; ...) the increment is 3; likewise to generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13; 13; ...) the increment is also 3. The actual type QTY will be dictated by the type of T. The value of increment must be positive.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation>The integer by which the index for the sequence is divided, effectively the number of times the sequence generates the same sequence item value before incrementing to the next sequence item value. 
Example:  To generate the sequence (1; 1; 1; 2; 2; 2; 3; 3; 3; ...) the denominator is 3.
The use of the denominator is to allow multiple generated sequences to periodically scan a multidimensional space. For example, an (abstract) TV screen uses 2 such generators for the columns and rows of pixels. For instance, if there are 200 scan lines and 320 raster colunmns, the column-generator would have denominator 1 and the line-generator would have denominator 320.
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="period" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation>If not null or nullFlavored, specifies that the sequence alternates, i.e., after this many increments, the sequence item values roll over to start from the initial sequence item value. 
Example:   The sequence (1; 2; 3; 1; 2; 3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period 3 too.
The period allows to repeatedly sample the same sample space. The &#34;waveform&#34; of this periodic generator is always a &#34;saw&#34;, just like the x-function of your oscilloscope.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_PQ">
    <xsd:annotation>
      <xsd:documentation>A periodic or monotone sequence of values generated from a few parameters, rather than being enumerated. Used to specify regular sampling points for biosignals.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_PQ-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-2">
            <sch:assert test="not(period) or (period/@nullFlavor) or (period/@value &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_PQ-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The first item in this sequence. This is the start-value of the generated list.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between one value and its previous different value. 

For example: To generate the sequence (1; 4; 7; 10; 13; ...) the increment is 3; likewise to generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13; 13; ...) the increment is also 3. The actual type QTY will be dictated by the type of T. The value of increment must be positive.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation>The integer by which the index for the sequence is divided, effectively the number of times the sequence generates the same sequence item value before incrementing to the next sequence item value. 
Example:  To generate the sequence (1; 1; 1; 2; 2; 2; 3; 3; 3; ...) the denominator is 3.
The use of the denominator is to allow multiple generated sequences to periodically scan a multidimensional space. For example, an (abstract) TV screen uses 2 such generators for the columns and rows of pixels. For instance, if there are 200 scan lines and 320 raster colunmns, the column-generator would have denominator 1 and the line-generator would have denominator 320.
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="period" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation>If not null or nullFlavored, specifies that the sequence alternates, i.e., after this many increments, the sequence item values roll over to start from the initial sequence item value. 
Example:   The sequence (1; 2; 3; 1; 2; 3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period 3 too.
The period allows to repeatedly sample the same sample space. The &#34;waveform&#34; of this periodic generator is always a &#34;saw&#34;, just like the x-function of your oscilloscope.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_REAL">
    <xsd:annotation>
      <xsd:documentation>A periodic or monotone sequence of values generated from a few parameters, rather than being enumerated. Used to specify regular sampling points for biosignals.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_REAL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-2">
            <sch:assert test="not(period) or (period/@nullFlavor) or (period/@value &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_REAL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="REAL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The first item in this sequence. This is the start-value of the generated list.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between one value and its previous different value. 

For example: To generate the sequence (1; 4; 7; 10; 13; ...) the increment is 3; likewise to generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13; 13; ...) the increment is also 3. The actual type QTY will be dictated by the type of T. The value of increment must be positive.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation>The integer by which the index for the sequence is divided, effectively the number of times the sequence generates the same sequence item value before incrementing to the next sequence item value. 
Example:  To generate the sequence (1; 1; 1; 2; 2; 2; 3; 3; 3; ...) the denominator is 3.
The use of the denominator is to allow multiple generated sequences to periodically scan a multidimensional space. For example, an (abstract) TV screen uses 2 such generators for the columns and rows of pixels. For instance, if there are 200 scan lines and 320 raster colunmns, the column-generator would have denominator 1 and the line-generator would have denominator 320.
</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="period" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation>If not null or nullFlavored, specifies that the sequence alternates, i.e., after this many increments, the sequence item values roll over to start from the initial sequence item value. 
Example:   The sequence (1; 2; 3; 1; 2; 3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period 3 too.
The period allows to repeatedly sample the same sample space. The &#34;waveform&#34; of this periodic generator is always a &#34;saw&#34;, just like the x-function of your oscilloscope.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_CO">
    <xsd:annotation>
      <xsd:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_CO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_CO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_CO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_CO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the low limit. If the low limit is not known, a nullFlavor may be specified.
The low limit SHALL NOT be positive infinity
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the high limit. If the high limit is not known, a nullFlavor may be specified.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="any" type="CO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Specifies that some particular value lies within the interval.

This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_CO">
    <xsd:annotation>
      <xsd:documentation>Abstract; specializes ANY

Parameter: T : QTY

An unordered set of distinct values which are quantities. 

Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).

QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).

QSETs SHALL not contain null or nullFlavored values as members of the set.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_CO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the &#60;i&#62;QSET&#60;/i&#62; is not valid, then the &#60;i&#62;QSET&#60;/i&#62; SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS">
    <xsd:annotation>
      <xsd:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the low limit. If the low limit is not known, a nullFlavor may be specified.
The low limit SHALL NOT be positive infinity
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the high limit. If the high limit is not known, a nullFlavor may be specified.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="any" type="TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Specifies that some particular value lies within the interval.

This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_MO">
    <xsd:annotation>
      <xsd:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_MO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_MO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_MO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_MO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the low limit. If the low limit is not known, a nullFlavor may be specified.
The low limit SHALL NOT be positive infinity
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the high limit. If the high limit is not known, a nullFlavor may be specified.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="any" type="MO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Specifies that some particular value lies within the interval.

This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_MO">
    <xsd:annotation>
      <xsd:documentation>Abstract; specializes ANY

Parameter: T : QTY

An unordered set of distinct values which are quantities. 

Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).

QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).

QSETs SHALL not contain null or nullFlavored values as members of the set.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_MO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the &#60;i&#62;QSET&#60;/i&#62; is not valid, then the &#60;i&#62;QSET&#60;/i&#62; SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_PQ">
    <xsd:annotation>
      <xsd:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_PQ-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_PQ-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_PQ-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_PQ-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the low limit. If the low limit is not known, a nullFlavor may be specified.
The low limit SHALL NOT be positive infinity
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the high limit. If the high limit is not known, a nullFlavor may be specified.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="any" type="PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Specifies that some particular value lies within the interval.

This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_PQ">
    <xsd:annotation>
      <xsd:documentation>Abstract; specializes ANY

Parameter: T : QTY

An unordered set of distinct values which are quantities. 

Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).

QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).

QSETs SHALL not contain null or nullFlavored values as members of the set.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_PQ-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the &#60;i&#62;QSET&#60;/i&#62; is not valid, then the &#60;i&#62;QSET&#60;/i&#62; SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_REAL">
    <xsd:annotation>
      <xsd:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_REAL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_REAL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_REAL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_REAL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the low limit. If the low limit is not known, a nullFlavor may be specified.
The low limit SHALL NOT be positive infinity
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the high limit. If the high limit is not known, a nullFlavor may be specified.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="any" type="REAL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Specifies that some particular value lies within the interval.

This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_REAL">
    <xsd:annotation>
      <xsd:documentation>Abstract; specializes ANY

Parameter: T : QTY

An unordered set of distinct values which are quantities. 

Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).

QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).

QSETs SHALL not contain null or nullFlavored values as members of the set.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_REAL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the &#60;i&#62;QSET&#60;/i&#62; is not valid, then the &#60;i&#62;QSET&#60;/i&#62; SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT">
    <xsd:annotation>
      <xsd:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the low limit. If the low limit is not known, a nullFlavor may be specified.
The low limit SHALL NOT be positive infinity
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>This is the high limit. If the high limit is not known, a nullFlavor may be specified.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of T</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="any" type="INT" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Specifies that some particular value lies within the interval.

This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT">
    <xsd:annotation>
      <xsd:documentation>Abstract; specializes ANY

Parameter: T : QTY

An unordered set of distinct values which are quantities. 

Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).

QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).

QSETs SHALL not contain null or nullFlavored values as members of the set.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 

Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the &#60;i&#62;QSET&#60;/i&#62; is not valid, then the &#60;i&#62;QSET&#60;/i&#62; SHALL be nullFlavored, irrespective of whether originalText has a value or not.

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as the difference between two sets.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="minuend" type="QSET_TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set from which the second set is subtracted</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="subtrahend" type="QSET_TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set that is subtracted from the first set</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS">
    <xsd:annotation>
      <xsd:documentation>Specifies a QSET as a union of other sets</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>a list of other QSETs that are involved in the union</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as the periodic hull between two sets. 

A periodic hull may be generated by comparing two sets that interleave. For QSET values &#60;b&#62;A&#60;/b&#62; and &#60;b&#62;B&#60;/b&#62; to interleave, the occurrence intervals of both groups can be arranged in pairs of corresponding occurrence intervals. It must further hold that for all corresponding occurrence intervals a  &#38;sube; A and b &#38;sube; B, a starts before b starts (or at the same time) and b ends after a ends (or at the same time).

The interleaves-relation holds when two schedules have the same average frequency, and when the second schedule never &#34;outpaces&#34; the first schedule. That is, no occurrence interval in the second schedule may start before its corresponding occurrence interval in the first schedule.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="low" type="QSET_TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set used as the basis for the periodic hull operation</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="QSET_TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set that is used as the parameter for the periodic hull operation.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as an enumeration of simple values. This is a shortcut form for specifying the same values as singleton intervals</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="term" type="TS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>a list of values that are in the set. The set is actually constructed as the union of the intervals implied by the precision implicit in the definition of T. For some types of QTY, this is either trivial (INT) or ambiguous (RTO) and QSS doesnt really make sense for these type. QSS is a useful type for TS in particular</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSC_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as an coded value that describes a predefined QSET(TS).</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSC_TS-0">
            <sch:assert test="@nullFlavor or (code and not(code/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code: no translations">
          <sch:rule abstract="true" id="QSC_TS-1">
            <sch:assert test="not(code) or (not(code/translation))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code: no source">
          <sch:rule abstract="true" id="QSC_TS-2">
            <sch:assert test="not(code) or (not(code/@source))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="code" type="CD" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A predefined code that fully and unambiguously describes a set of times.

The possible set of codes that are allowed for use in this attribute should be described in conformance statements. HL7 defines the set of codes described below in GTSAbbrevation, and all information processing entities claiming direct conformance to this standard SHALL support the codes AM, PM, BID, TID, QID, JB, and JE if this type is supported.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS">
    <xsd:annotation>
      <xsd:documentation>An interval of time that recurs periodically. PIVL has two properties, phase and period/frequency. phase specifies the &#34;interval prototype&#34; that is repeated on the period/frequency.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS-0">
            <sch:assert test="not(period) or not(frequency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="count: positive">
          <sch:rule abstract="true" id="PIVL_TS-2">
            <sch:assert test="not(count) or ((count/@nullFlavor) or (count/@value &#62; 0))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="phase" type="IVL_TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A prototype of the repeating interval, specifying the duration of each occurrence and anchors the PIVL sequence at a certain point in time. phase also marks the anchor point in time for the entire series of periodically recurring intervals. If count is null or nullFlavored, the recurrence of a PIVL has no beginning or ending, but is infinite in both future and past. 

The width of the phase SHALL be less than or equal to the period</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="period" type="PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A time duration specified as a reciprocal measure of the frequency at which the PIVL repeats.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="frequency" type="RTO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The number of times the PIVL repeats (numerator) within a specified time-period (denominator). The numerator is an integer, and the denominator is a PQ.TIME.

Only one of period and frequency should be specified. The form chosen should be the form that most naturally conveys the idea to humans. i.e. Every 10 mins (period) or twice a day (frequency).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="count" type="INT" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The number of times the period repeats in total. If count is null or nullFlavored, then the period repeats indefinitely both before and after the anchor implicit in the phase</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional">
          <xsd:annotation>
            <xsd:documentation>If and how the repetitions are aligned to the cycles of the underlying calendar (e.g., to distinguish every 30 days from &#34;the 5th of every month&#34;.) A non-aligned PIVL recurs independently from the calendar. An aligned PIVL is synchronized with the calendar.
If populated, the value of this attribute SHALL be taken from the HL7 CalendarCycle code system. </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional">
          <xsd:annotation>
            <xsd:documentation>Indicates whether the exact timing is up to the party executing the schedule e.g., to distinguish &#34;every 8 hours&#34; from &#34;3 times a day&#34;.

Note: this is sometimes referred to as &#34;institution specified timing&#34;.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS">
    <xsd:annotation>
      <xsd:documentation>Specifies a periodic interval of time where the recurrence is based on activities of daily living or other important events that are time-related but not fully determined by time. 
Example: &#34;one hour after breakfast&#34; specifies the beginning of the interval at one hour after breakfast is finished. Breakfast is assumed to occur before lunch but is not determined to occur at any specific time</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS-0">
            <sch:assert test="@nullFlavor or (event)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>An interval of elapsed time (duration, not absolute point in time) that marks the offsets for the beginning, width and end of the EIVL measured from the time each such event actually occurred. 

Example: if the specification is &#34;one hour before breakfast for 10 minutes&#34;, code is CM, IVL.low of offset is -1 h and the IVL.high of offset is -50 min.

The offset SHALL be null if the event code specifies &#34;before&#34;, &#34;after&#34; or &#34;between meals&#34;. The offset SHALL be nonNull if the EIVL is nonNull and the event code is C, CM, CD, or CV. The offset may or may not be null for the event codes HS and WAKE.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional">
          <xsd:annotation>
            <xsd:documentation>A code for a common (periodic) activity of daily living based on which the event related periodic interval is specified. Events that qualify for being adopted in the domain of this attribute must satisfy the following requirements:
	the event commonly occurs on a regular basis
	the event is being used for timing activities, and
	the event is not entirely determined by time

If these criteria are not met, the relationship of the event and its time must be communicated using structures outside the datatypes defined in this standard.

If populated, the value of this attribute SHALL be taken from the HL7 TimingEvent code system.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as the difference between two sets.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="minuend" type="QSET_PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set from which the second set is subtracted</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="subtrahend" type="QSET_PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set that is subtracted from the first set</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>

      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as an intersection of other sets.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_PQ" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of other QSETs that are involved in the intersection</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_PQ">
    <xsd:annotation>
      <xsd:documentation>Specifies a QSET as a union of other sets</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_PQ" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>a list of other QSETs that are involved in the union</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as the periodic hull between two sets. 

A periodic hull may be generated by comparing two sets that interleave. For QSET values &#60;b&#62;A&#60;/b&#62; and &#60;b&#62;B&#60;/b&#62; to interleave, the occurrence intervals of both groups can be arranged in pairs of corresponding occurrence intervals. It must further hold that for all corresponding occurrence intervals a  &#38;sube; A and b &#38;sube; B, a starts before b starts (or at the same time) and b ends after a ends (or at the same time).

The interleaves-relation holds when two schedules have the same average frequency, and when the second schedule never &#34;outpaces&#34; the first schedule. That is, no occurrence interval in the second schedule may start before its corresponding occurrence interval in the first schedule.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="low" type="QSET_PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set used as the basis for the periodic hull operation</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="high" type="QSET_PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The set that is used as the parameter for the periodic hull operation.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes QSET

Specifies a QSET as an enumeration of simple values. This is a shortcut form for specifying the same values as singleton intervals</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="term" type="PQ" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>a list of values that are in the set. The set is actually constructed as the union of the intervals implied by the precision implicit in the definition of T. For some types of QTY, this is either trivial (INT) or ambiguous (RTO) and QSS doesnt really make sense for these type. QSS is a useful type for TS in particular</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_BL">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_BL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_BL">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_BL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_BL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_BL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="BL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ST">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ST" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ST">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ST-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ST-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ST-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ST" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_SC">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_SC" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_SC">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_SC-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_SC-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_SC-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="SC" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TEL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TEL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_II">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_II" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_II">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_II-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_II-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_II-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="II" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CD">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_CD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CD">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CD-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="CD" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CO">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_CO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CO">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CO-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="CO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CS">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_CS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CS">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CS-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="CS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_AD">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_AD" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_AD">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_AD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_AD-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_AD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="AD" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_EN" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="EN" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TS" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TS" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_RTO">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_RTO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_RTO">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_RTO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_RTO-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_RTO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="RTO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_MO">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_MO" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_MO">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_MO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_MO-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_MO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="MO" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_PQ" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_PQ-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_PQ-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_PQ-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="PQ" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_REAL">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_REAL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_REAL">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_REAL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_REAL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_REAL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="REAL" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.

NPPD&#38;lt;T&#38;gt; may be used where only one value for T may be true. The sum of the probabilities should be &#38;lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed 1</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_INT" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>The list of values with probabilities for the histogram</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT">
    <xsd:annotation>
      <xsd:documentation>Specializes ANY

Parameter: T : ANY

A generic datatype extension used to specify a probability expressing the information producer&#39;s belief that the given value holds.</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlInformationRoot or @controlInformationExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="INT" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation>The value of T which the probability refers to</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="probability" type="Decimal" use="optional">
          <xsd:annotation>
            <xsd:documentation>The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 

There is no &#34;default probability&#34; that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean &#34;uncertain&#34;, and a simple T does not mean &#34;certain&#34;. In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_BL">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_BL-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_BL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_ED-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_ED" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ST">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_ST-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_ST" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_SC">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_SC-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_SC" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_TEL-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_II">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_II-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_II" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CD">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_CD-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_CD" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CO">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_CO-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_CO" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CS">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_CS-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_CS" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_AD">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_AD-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_AD" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_EN-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_EN" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_TS-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_TS" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_RTO">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_RTO-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_RTO" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_MO">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_MO-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_MO" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_PQ">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_PQ-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_PQ" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_REAL">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_REAL-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_REAL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT">
    <xsd:annotation>
      <xsd:documentation>Specializes LIST

Parameter: T : ANY
A collection that set of items in historical order</xsd:documentation>
      <xsd:appinfo>
        <sch:pattern name="validTime required">
          <sch:rule abstract="true" id="HIST_INT-0">
            <sch:assert test="item/@validTimeLow or item/@validTimeHigh" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="LIST_INT" />
    </xsd:complexContent>
  </xsd:complexType>
</xsd:schema>