package drl;

import org.semanticweb.owlapi.model.*;
import org.semanticweb.owlapi.vocab.*;
import uk.ac.manchester.cs.owl.owlapi.*;

import org.w3.x2001.xmlschema.*;
import javax.xml.namespace.QName;

import javax.xml.bind.*;
import java.util.Set;
import java.util.HashSet;

import org.test.*;
import org.test.beans.*;

global OWLOntology ontology;
global OWLOntologyManager manager;
global OWLDataFactory factory;
global String tns;

declare List @typesafe(false) end

declare Link
    src : OpenAttrs
    tgt : OWLAxiom
end

declare Anon
    cld : OpenAttrs
    sup : OpenAttrs
    kls : OWLClassExpression
    and : boolean
    rst : boolean
end

function OWLDatatype mapXsdDatatype( QName qn, OWLDataFactory factory ) {
    String px = qn.getNamespaceURI() + "#";
        if ( px.equals( Namespaces.XSD.toString() ) ) {
            if ( "ID".equals( qn.getLocalPart() ) ) {
                return OWL2DatatypeImpl.getDatatype( OWL2Datatype.getDatatype( IRI.create( px, "anyURI" ) ) );
            } else if ( "anyType".equals( qn.getLocalPart() ) ) {
                return factory.getTopDatatype();
            } else {
                return OWL2DatatypeImpl.getDatatype( OWL2Datatype.getDatatype( IRI.create( px, qn.getLocalPart() ) ) );
            }
        } else {
            return factory.getOWLDatatype( IRI.create( px, qn.getLocalPart() ) );
        }
}

query "axioms" ( Set $set )
    accumulate( Link( $s, $t ; ),
                $set : collectSet( $t ) )
end




rule "Visit Complex Types with Group Content"
when
    $c : ComplexType( $model : group != null )
then
    insertLogical( new Anon( $model, $c, null, true, false ) );
end
rule "Visit Complex Types with All Content"
when
    $c : ComplexType( $model : all != null )
then
    insertLogical( new Anon( $model, $c, null, true, false ) );
end
rule "Visit Complex Types with Choice Content"
when
    $c : ComplexType( $model : choice != null )
then
    insertLogical( new Anon( $model, $c, null, false, false ) );
end
rule "Visit Complex Types with Sequence Content"
when
    $c : ComplexType( $model : sequence != null )
then
    insertLogical( new Anon( $model, $c, null, true, false ) );
end

rule "Visit Extension Types with Group Content"
when
    $c : ComplexType( $ext : complexContent!.extension != null )
    ExtensionType( this == $ext, $model : group != null )
then
    insertLogical( new Anon( $model, $c, null, true, false ) );
end
rule "Visit Extension Types with All Content"
when
    $c : ComplexType( $ext : complexContent!.extension != null )
    ExtensionType( this == $ext,  $model : all != null )
then
    insertLogical( new Anon( $model, $c, null, true, false ) );
end
rule "Visit Extension Types with Choice Content"
when
    $c : ComplexType( $ext : complexContent!.extension != null )
    ExtensionType( this == $ext,  $model : choice != null )
then
    insertLogical( new Anon( $model, $c, null, false, false ) );
end
rule "Visit Extension Types with Sequence Content"
when
    $c : ComplexType( $ext : complexContent!.extension != null )
    ExtensionType( this == $ext,  $model : sequence != null )
then
    insertLogical( new Anon( $model, $c, null, true, false ) );
end



rule "Visit Group Particles"
when
    $g : Group( $parts : particle )
    $x : JAXBElement( $o : value, $n : name ) from $parts
then
    insertLogical( new Anon( (OpenAttrs) $o, $g, null, ! "choice".equals( $n.getLocalPart() ), false ) );
end












declare ElemContext
    att : org.w3.x2001.xmlschema.Element
    ctx : OpenAttrs
end

declare AttrContext
    att : Attribute
    ctx : OpenAttrs
end

declare Dom
    prop : String
    klas : QName
end

declare Ran
    prop : String
    klas : QName
end

declare ODom
    prop : String
    klas : QName
end

declare ORan
    prop : String
    klas : QName
end

declare DataName
    name : QName
end

declare ObjectName
    name : QName
end


rule "Attribute Localization in ComplexType Extensions"
when
    ComplexType( $name : name, $ext: complexContent!.extension )
    ExtensionType( this == $ext, $atts : attributeOrAttributeGroup )
    ( $att : Attribute() from $atts
      or
      ( AttributeGroup( $inner : attributeOrAttributeGroup ) from $atts
        and
        $att : Attribute() from $inner
      )
    )
then
    insertLogical( new AttrContext( $att, $ext ) );
end

rule "Resolve Attribute Links"
when
    $ctx : AttrContext( $x, $att ; )
    $src : Attribute( this == $att, $ref : ref != null)
    $tgt : Attribute( id == $ref )
then
    modify ( $ctx ) { setCtx( $tgt ); }
end




















rule "Named Complex Types"
when
    $c : ComplexType( $name : name != null )
then
    insertLogical( new ObjectName( new QName( tns, $name ) ) );
    insertLogical(
        new Link(
            $c,
            factory.getOWLDeclarationAxiom( factory.getOWLClass( IRI.create( tns + "#", $name ) )
        ) ) );
end

rule "Named Simple Types"
when
    $s : SimpleType( $name : name )
then
    insertLogical( new DataName( new QName( tns, $name ) ) );
    insertLogical(
        new Link(
            $s,
            factory.getOWLDeclarationAxiom( factory.getOWLDatatype( IRI.create( tns + "#", $name ) )
        ) ) );
end


rule "Named Simple Types Range"
when
    $s : SimpleType( $name : name != null, union == null, restriction != null, restriction.base != null,
//                     restriction.facets.isEmpty(),
                     $baseURI : restriction.base.namespaceURI, $baseName : restriction.base.localPart )
then
    insertLogical(
        new Link(
            $s,
            factory.getOWLDatatypeDefinitionAxiom(
                factory.getOWLDatatype( IRI.create( tns+ "#", $name ) ),
                mapXsdDatatype( new QName( $baseURI, $baseName ), factory )
        ) ) );
end



rule "Named Simple Types Enum"
when
    $s : SimpleType( $name : name != null, $rest : restriction, $base : restriction.base, union == null,
                $facets : restriction.facets, restriction.facets.size() > 0 )
    accumulate( $jxb : JAXBElement( $tmp : value ) from $facets
                and
                $fax : Facet( $val : value ) from $tmp,
                $set : collectSet( factory.getOWLLiteral( $val,
                                                           OWL2Datatype.getDatatype( IRI.create( $base.getNamespaceURI() + "#", $base.getLocalPart() ) ) ) ) )
then
// TODO HERMIT DOES NOT LIKE THIS... reenable?
//    insertLogical(
//        new Link(
//            $rest,
//            factory.getOWLDatatypeDefinitionAxiom(
//                factory.getOWLDatatype( IRI.create( tns, $name ) ),
//                factory.getOWLDataOneOf( $set )
//        ) ) );
end














rule "Complex Type Inheritance by Extension"
when
    $c : ComplexType( $name : name, $cc : complexContent )
    ComplexContent( $ext : extension != null, extension.base != null,
                    $baseURI : extension.base.namespaceURI, $baseName : extension.base.localPart ) from $cc
then
    insertLogical(
        new Link(
            $ext,
            factory.getOWLSubClassOfAxiom(
                factory.getOWLClass( IRI.create( tns + "#", $name ) ),
                factory.getOWLClass( IRI.create( $baseURI + "#", $baseName ) )
        ) ) );
end

rule "Complex Type Extension Attribute"
when
    ComplexType( $name : name, $ext: complexContent!.extension )
    ExtensionType( this == $ext, $atts : attributeOrAttributeGroup )
    AttrContext( $att, $ext ; )
    Attribute( this == $att, $prop : name, $type : type, $opt : use )
then
    OWLDataProperty prop = factory.getOWLDataProperty( IRI.create( tns + "#", $prop ) );
    OWLClass dom = factory.getOWLClass( IRI.create( tns + "#", $name ) );
    OWLDataRange ran = mapXsdDatatype( $type, factory );

    insertLogical(
            new Link(
                $att,
                factory.getOWLDeclarationAxiom( prop )
            ) );

    Set set = new HashSet();
    set.add( factory.getOWLDataAllValuesFrom( prop, ran ) );
    set.add( factory.getOWLDataMaxCardinality( "prohibited".equals( $opt ) ? 0 : 1, prop, ran ) );
    set.add( factory.getOWLDataMinCardinality( "optional".equals( $opt ) || "prohibited".equals( $opt ) ? 0 : 1, prop, ran ) );

    insertLogical(
            new Link(
                $att,
                factory.getOWLSubClassOfAxiom( dom, factory.getOWLObjectIntersectionOf( set ) )
            ) );

    insertLogical( new Dom( $prop, new QName( tns, $name ) ) );
    insertLogical( new Ran( $prop, $type ) );
end






rule "Aggregate Data Domains"
salience -100000
when
    accumulate( Dom( $pro ; ),
        $pros : collectSet( $pro ) )
    $propName : String() from $pros
    accumulate( Dom( $propName, $domName ; ),
        $doms : collectSet( factory.getOWLClass( IRI.create( $domName.getNamespaceURI() + "#", $domName.getLocalPart() ) ) );
        $doms.size() > 0 )
then
    insertLogical(
            new Link(
                null,
                factory.getOWLDataPropertyDomainAxiom(
                                    factory.getOWLDataProperty( IRI.create( tns + "#", $propName ) ),
                                    $doms.size() == 1 ? (OWLClassExpression) $doms.iterator().next() : factory.getOWLObjectUnionOf( $doms )
                                    )
            ) );
end

rule "Aggregate Data Ranges"
salience -100000
when
    accumulate( Ran( $pro ; ),
        $pros : collectSet( $pro ) )
    $propName : String() from $pros
    accumulate( Ran( $propName, $ranName ; ),
        $rans : collectSet( mapXsdDatatype( $ranName, factory ) );
        $rans.size() > 0 )
then
    insertLogical(
            new Link(
                null,
                factory.getOWLDataPropertyRangeAxiom(
                                    factory.getOWLDataProperty( IRI.create( tns + "#", $propName ) ),
                                    $rans.size() == 1 ? (OWLDataRange) $rans.iterator().next() : factory.getOWLDataUnionOf( $rans )
                                    )
            ) );
end

rule "Aggregate Obj Domains"
salience -100000
when
    accumulate( ODom( $pro ; ),
        $pros : collectSet( $pro ) )
    $propName : String() from $pros
    accumulate( ODom( $propName, $domName ; ),
        $doms : collectSet( factory.getOWLClass( IRI.create( $domName.getNamespaceURI() + "#", $domName.getLocalPart() ) ) );
        $doms.size() > 0 )
then
    insertLogical(
            new Link(
                null,
                factory.getOWLObjectPropertyDomainAxiom(
                                    factory.getOWLObjectProperty( IRI.create( tns + "#", $propName ) ),
                                    $doms.size() == 1 ? (OWLClassExpression) $doms.iterator().next() : factory.getOWLObjectUnionOf( $doms )
                                    )
            ) );
end

rule "Aggregate Obj Ranges"
salience -100000
when
    accumulate( ORan( $pro ; ),
        $pros : collectSet( $pro ) )
    $propName : String() from $pros
    accumulate( ORan( $propName, $ranName ; ),
        $rans : collectSet( factory.getOWLClass( IRI.create( $ranName.getNamespaceURI() + "#", $ranName.getLocalPart() ) ) );
        $rans.size() > 0 )
then
    insertLogical(
            new Link(
                null,
                factory.getOWLObjectPropertyRangeAxiom(
                                    factory.getOWLObjectProperty( IRI.create( tns + "#", $propName ) ),
                                    $rans.size() == 1 ? (OWLClassExpression) $rans.iterator().next() : factory.getOWLObjectUnionOf( $rans )
                                    )
            ) );
end








query unravel( OpenAttrs $g, ComplexType $c )
    (
        ( Anon( $g, $c ; ) and $c := ComplexType( name != null ) )
        or
        ( Anon( $g, $x ; ) and unravel( $x, $c ; ) )
    )
end



rule "Element of Simple Type"
when
    $e : Element( $name : name, $type : type != null )
    Anon( $e, $par ; )
    ( DataName( $type ; ) or eval( ( $type.getNamespaceURI() + "#" ).equals( Namespaces.XSD.toString() ) ) )
    unravel( $par, $comp ; )
then
    OWLDataProperty prop = factory.getOWLDataProperty( IRI.create( tns + "#", $name ) );
    OWLClass dom = factory.getOWLClass( IRI.create( tns + "#", $comp.getName() ) );
    OWLDataRange ran = mapXsdDatatype( $type, factory );

    insertLogical(
            new Link(
                $e,
                factory.getOWLDeclarationAxiom( prop )
            ) );

    insertLogical( new Dom( $name, new QName( tns, $comp.getName() ) ) );
    insertLogical( new Ran( $name, $type ) );

end

rule "Element of Object Type"
when
    $e : Element( $name : name, $type : type != null )
    Anon( $e, $par ; )
    ObjectName( $type ; )
    unravel( $par, $comp ; )
then
    OWLObjectProperty prop = factory.getOWLObjectProperty( IRI.create( tns + "#", $name ) );
    OWLClass dom = factory.getOWLClass( IRI.create( tns + "#", $comp.getName() ) );
    OWLClass ran = factory.getOWLClass( IRI.create( $type.getNamespaceURI() + "#", $type.getLocalPart() ) );

    insertLogical(
            new Link(
                $e,
                factory.getOWLDeclarationAxiom( prop )
            ) );

    insertLogical( new ODom( $name, new QName( tns, $comp.getName() ) ) );
    insertLogical( new ORan( $name, $type ) );
end





rule "Anonymous Complex Types"
salience 100
when
    $el : Element( $loc : complexType, $name : name, type == null )
    $ct : LocalComplexType( this == $loc, name == null )
then
    String typeName = $name.substring( 0, 1 ).toUpperCase() + $name.substring( 1 ); /* + "_Range" */
    modify ( $ct ) { setName( typeName ); }
    modify ( $el ) { setType( new QName( tns, typeName ) ); }
end






rule "Build Data Element"
when
    $e : Element( $name : name, $type : type != null, $min : minOccurs, $max : maxOccurs )
    $a : Anon( $e ; kls == null )
    ( DataName( $type ; ) or eval( ( $type.getNamespaceURI() + "#" ).equals( Namespaces.XSD.toString() ) ) )
then
    OWLDataProperty prop = factory.getOWLDataProperty( IRI.create( tns + "#", $name ) );
    OWLDataRange ran = mapXsdDatatype( $type, factory );

    Set set = new HashSet();


    OWLDataAllValuesFrom all = factory.getOWLDataAllValuesFrom( prop, ran );
    set.add( all );

    if ( $max != null && ! "unbounded".equals( $max ) ) {
        OWLDataMaxCardinality max = factory.getOWLDataMaxCardinality(
                        Integer.parseInt( $max ),
                        prop,
                        ran );
        set.add( max );
    }
    if ( $min != null ) {
        OWLDataMinCardinality min = factory.getOWLDataMinCardinality(
                        $min.intValue(),
                        prop,
                        ran );
        set.add( min );
    }

    modify ( $a ) { setKls( factory.getOWLObjectIntersectionOf( set ) ); }

end


rule "Build Object Element"
when
    $e : Element( $name : name, $type : type != null, $min : minOccurs, $max : maxOccurs )
    $a : Anon( $e ; kls == null )
    ObjectName( $type ; )
then
    OWLObjectProperty prop = factory.getOWLObjectProperty( IRI.create( tns + "#", $name ) );
    OWLClass ran = factory.getOWLClass( IRI.create( $type.getNamespaceURI() + "#", $type.getLocalPart() ) );

    Set set = new HashSet();

    OWLObjectAllValuesFrom all = factory.getOWLObjectAllValuesFrom( prop, ran );
    set.add( all );

    if ( $max != null && ! "unbounded".equals( $max ) ) {
        OWLObjectMaxCardinality max = factory.getOWLObjectMaxCardinality(
                        Integer.parseInt( $max ),
                        prop,
                        ran );
        set.add( max );
    }
    if ( $min != null ) {
        OWLObjectMinCardinality min = factory.getOWLObjectMinCardinality(
                        $min.intValue(),
                        prop,
                        ran );
        set.add( min );
    }

    modify ( $a ) { setKls( factory.getOWLObjectIntersectionOf( set ) ); }

end

rule "Build Group"
when
    $x : Anon( $group, $c ; kls == null, $and : and )
    accumulate( Anon( $e, $group, $kls ; $kls != null ),
        $set : collectSet( $kls );
        $set.size() > 0 )
then
    System.out.println( "Found a group " + $and );
    modify ( $x ) { setKls( $and ? factory.getOWLObjectIntersectionOf( $set ) : factory.getOWLObjectUnionOf( $set ) ); }
end



rule "Build Complex Type"
when
    $c : ComplexType( $name : name != null )
    $x : Anon( $group, $c ; $kls : kls != null )
then
    OWLClass dom = factory.getOWLClass( IRI.create( tns + "#", $name ) );
    insert( new Link( $group, factory.getOWLSubClassOfAxiom( dom, $kls ) ) );
end


rule "Attribute Group Ref Link in Extensions"
salience 100
when
    $ref : AttributeGroupRef( $refName : ref!.localPart )
    $ext : ExtensionType( $atts : attributeOrAttributeGroup contains $ref )
    $tgt : AttributeGroup( name == $refName )
then
    int idx = $atts.indexOf( $ref );
    modify ( $ext ) {
        getAttributeOrAttributeGroup().set( idx, $tgt );
    }
end

rule "Orphan attributes in Orphan groups"
when
    $agg : AttributeGroup( $refName : name == $refName, $orphans : attributeOrAttributeGroup )
    not    AttributeGroupRef( ref!.localPart == $refName )
    $att : Attribute( this memberOf $orphans, $prop : name != null, $type : type != null )
then
    OWLDataProperty prop = factory.getOWLDataProperty( IRI.create( tns + "#", $prop ) );
    OWLDataRange ran = mapXsdDatatype( $type, factory );
    insertLogical(
            new Link(
                $att,
                factory.getOWLDeclarationAxiom( prop )
            ) );
    insertLogical( new Ran( $prop, $type ) );
end